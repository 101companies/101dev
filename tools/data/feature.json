[{
	"name":"Access control",
	"summary":"provide access control to company data and services",
	"description":"This feature covers the capability of [[access control]] for the [[101companies:System]].  Implementations may target different data and resources of the system that should be subjected to access control. The actual access control policy may also be freely chosen. To give a concrete example, access to salaries of selected employees such as managers could be dynamically controlled. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"javaExorcism"},
		{"name":"seam"}]
},
{
	"name":"Company",
	"summary":"the data model for companies",
	"description":"There are companies, departments, and employees.\n\n* Each company has a unique ''name''.\n* Each company consists of (possibly nested) ''departments''.\n* Each department has a unique ''name''.\n* Each department has a manager.\n* Each department aggregates ''employees'' and ''sub-departments''.\n* Each employee has a unique ''name''.\n* Additional properties: ''salary'' and possibly others.\n* Each employee serves only in one position in the company.\n* Managers are employees, too.\n\nThis data model is interesting in so far that it immediately exercises various facets of data modeling such as properties, cardinalities, recursion, and containment. Concrete implementations may easily assume refinements of the specification, if additional facets should be covered. For instance, [[:Category:inheritance]] can be exercised by deriving managers from employees through specialization. Further, the basic model at hand essentially suggests [[containment relationship]]s (i.e., tree shape), but it is easy to involve [[reference relationship]]s; see, for example, [[101feature:Mentoring]]. Finally, the basic model and straightforward refinements are suitable for the illustration of major programming techniques and design patterns. For instance, the basic structure at hand may suggest application of the [[Composite pattern]].",
	"illustration":"Here is an illustrative description of a company called \"meganalysis\".\n\nWe use some concrete syntax to render the structure.\n\nSome [[101companies:Implementations]] support (a variant of) this concrete syntax.\n\nSee [[101implementation:antlrAcceptor]] for example.\n\n<pre>\ncompany \"meganalysis\" {\n  department \"Research\" {\n    manager \"Craig\" {\n      address \"Redmond\"\n      salary 123456\n    }\n    employee \"Erik\" {\n      address \"Utrecht\"\n      salary 12345\n    }\n    ...\n  }\n  department \"Development\" {\n    manager \"Ray\" {\n      address \"Redmond\"\n      salary 234567\n    }\n    department \"Dev1\" { ... }\n    department \"Dev2\" { ... }\n  }\n}\n<\/pre>\n\nHence, there are two top-level departments \"Research\" and \"Development\". The \"Development\" department further breaks down into two sub-departments \"Dev1\" and \"Dev2\" (and possibly further). All departments have a manager. Some departments have employees. All employees have salaries. It happens that salaries decrease with the nesting level.\n\n[[Category:101basics]]",
	"implementations":[{"name":"antlrAcceptor"},
		{"name":"antlrLexer"},
		{"name":"antlrObjects"},
		{"name":"antlrParser"},
		{"name":"antlrTrees"},
		{"name":"aspectJ"},
		{"name":"clojureRefs"},
		{"name":"cobol"},
		{"name":"csharp"},
		{"name":"csharpLinqToXml"},
		{"name":"dom"},
		{"name":"dph"},
		{"name":"ef"},
		{"name":"emf"},
		{"name":"erlang"},
		{"name":"fsharp"},
		{"name":"groovyDataFlowVariables"},
		{"name":"gwt"},
		{"name":"hadoop"},
		{"name":"happstack"},
		{"name":"haskell"},
		{"name":"haskellCGI"},
		{"name":"haskellConcurrent"},
		{"name":"haskellDB"},
		{"name":"haskellLogger"},
		{"name":"haskellParser"},
		{"name":"hdbc"},
		{"name":"hibernate"},
		{"name":"hibernate2"},
		{"name":"html5XMLHttpRequest"},
		{"name":"html5ajax"},
		{"name":"html5indexedDatabase"},
		{"name":"html5local"},
		{"name":"html5session"},
		{"name":"html5tree"},
		{"name":"hxt"},
		{"name":"hxtPickler"},
		{"name":"javaComposition"},
		{"name":"javaExorcism"},
		{"name":"javaInheritance"},
		{"name":"javaLexer"},
		{"name":"javaMultithreading"},
		{"name":"javaParseLib"},
		{"name":"javaParser"},
		{"name":"javaRmi"},
		{"name":"javaScanner"},
		{"name":"javaStatic"},
		{"name":"javaSyb"},
		{"name":"javaTemplate"},
		{"name":"javaTree"},
		{"name":"javaVisitor"},
		{"name":"javawsServer"},
		{"name":"jaxbChoice"},
		{"name":"jaxbComposition"},
		{"name":"jaxbExtension"},
		{"name":"jaxbSubstitution"},
		{"name":"jdom"},
		{"name":"jgralab"},
		{"name":"jocamlJoinPatterns"},
		{"name":"jsf"},
		{"name":"kiama"},
		{"name":"py3k"},
		{"name":"qt"},
		{"name":"sax"},
		{"name":"scala"},
		{"name":"scala2"},
		{"name":"scalaAkkaActors"},
		{"name":"scalaXML"},
		{"name":"seam"},
		{"name":"seaside"},
		{"name":"silverlight"},
		{"name":"sqlServer"},
		{"name":"strutsAnnotation"},
		{"name":"strutsXml"},
		{"name":"swing"},
		{"name":"syb"},
		{"name":"wcf"},
		{"name":"webDSL"},
		{"name":"wp7"},
		{"name":"wxHaskell"},
		{"name":"xom"},
		{"name":"xpathAPI"},
		{"name":"xquery"},
		{"name":"xsdClasses"},
		{"name":"xsdDataSet"},
		{"name":"xslt"},
		{"name":"zend"}]
},
{
	"name":"Concurrency",
	"summary":"make simultaneous operations on companies interact",
	"description":"This feature covers the capability of [[Concurrency|concurrency]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"haskellConcurrent"}]
},
{
	"name":"Cut",
	"summary":"an operation to cut all salaries of employees in half",
	"description":"The operation for cutting salaries serves a simple example of an [[endogenous transformation]] on company data. The overall shape of a company (in terms of employees and departments at all levels) remains unchanged. The transformation is solely focused on employees, in fact, their salaries. Depending on programming language and technology, the transformation will be implemented [[Pure computation|purely]] or [[Impure computation|impurely]]. One can also vary the basic behavior of cutting the salaries of all employees, if the resulting variations are suited to demonstrate some programming techniques or characteristics of specific programming technologies. For instance, more selective schemes of cutting salaries may be to only cut salaries of managers or only of those employees who are (not) directly associated with the leaf companies in the structure.",
	"illustration":"Let us illustrate the feature with a SQL query to be applied to an instance of a straightforward relational schema for companies.\nThe following statement uses an inner SELECT query to determine the company id from the company name \"meganalysis\", \nwith which, in turn, it identifies the employee records whose salaries are to be updated.\n\n<syntaxhighlight lang=\"sql\">\nUPDATE employee\n SET salary = salary \/ 2\n WHERE cid =\n  (SELECT id FROM company\n   WHERE name = \"meganalysis\");\n<\/syntaxhighlight>\nThe snippet originates from [[101implementation:mySql]].\n\n[[Category:101basics]]",
	"implementations":[{"name":"antlrObjects"},
		{"name":"aspectJ"},
		{"name":"clojureRefs"},
		{"name":"cobol"},
		{"name":"csharp"},
		{"name":"csharpLinqToXml"},
		{"name":"dom"},
		{"name":"dph"},
		{"name":"ef"},
		{"name":"emf"},
		{"name":"erlang"},
		{"name":"fsharp"},
		{"name":"groovyDataFlowVariables"},
		{"name":"gwt"},
		{"name":"hadoop"},
		{"name":"happstack"},
		{"name":"haskell"},
		{"name":"haskellCGI"},
		{"name":"haskellConcurrent"},
		{"name":"haskellDB"},
		{"name":"haskellLogger"},
		{"name":"haskellParser"},
		{"name":"hdbc"},
		{"name":"hibernate"},
		{"name":"hibernate2"},
		{"name":"html5XMLHttpRequest"},
		{"name":"html5ajax"},
		{"name":"html5indexedDatabase"},
		{"name":"html5local"},
		{"name":"html5session"},
		{"name":"html5tree"},
		{"name":"hxt"},
		{"name":"hxtPickler"},
		{"name":"javaComposition"},
		{"name":"javaExorcism"},
		{"name":"javaInheritance"},
		{"name":"javaLexer"},
		{"name":"javaMultithreading"},
		{"name":"javaParser"},
		{"name":"javaRmi"},
		{"name":"javaScanner"},
		{"name":"javaStatic"},
		{"name":"javaSyb"},
		{"name":"javaTemplate"},
		{"name":"javaTree"},
		{"name":"javaVisitor"},
		{"name":"javawsServer"},
		{"name":"jaxbChoice"},
		{"name":"jaxbComposition"},
		{"name":"jaxbExtension"},
		{"name":"jaxbSubstitution"},
		{"name":"jdom"},
		{"name":"jgralab"},
		{"name":"jocamlJoinPatterns"},
		{"name":"jsf"},
		{"name":"kiama"},
		{"name":"py3k"},
		{"name":"qt"},
		{"name":"sax"},
		{"name":"scala"},
		{"name":"scala2"},
		{"name":"scalaAkkaActors"},
		{"name":"scalaXML"},
		{"name":"seam"},
		{"name":"seaside"},
		{"name":"silverlight"},
		{"name":"sqlServer"},
		{"name":"strutsAnnotation"},
		{"name":"strutsXml"},
		{"name":"swing"},
		{"name":"syb"},
		{"name":"wcf"},
		{"name":"wcfRest"},
		{"name":"webDSL"},
		{"name":"wp7"},
		{"name":"wxHaskell"},
		{"name":"xom"},
		{"name":"xpathAPI"},
		{"name":"xquery"},
		{"name":"xsdClasses"},
		{"name":"xsdDataSet"},
		{"name":"xslt"},
		{"name":"zend"}]
},
{
	"name":"Depth",
	"summary":"an operation to determine the depth of department nesting",
	"description":"* The depth of a department is 1 + the maximum of the depths of its subdepartments.\n* In particular, the depth of a department without subdepartments is 1.\n* The depth of a company is the maximum of the depths of its (immediate) departments.\n\n[[Category:101extras]]",
	"implementations":[{"name":"aspectJ"},
		{"name":"cobol"},
		{"name":"csharp"},
		{"name":"csharpLinqToXml"},
		{"name":"ef"},
		{"name":"javaSyb"},
		{"name":"jgralab"},
		{"name":"kiama"},
		{"name":"sqlServer"},
		{"name":"syb"},
		{"name":"xquery"},
		{"name":"xslt"}]
},
{
	"name":"Distribution",
	"summary":"distribute companies or departments in a computer network",
	"description":"This feature covers the capability of [[distribution]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"gwt"},
		{"name":"happstack"},
		{"name":"haskellCGI"},
		{"name":"javaRmi"},
		{"name":"wcf"},
		{"name":"wcfRest"},
		{"name":"webDSL"}]
},
{
	"name":"Editing",
	"summary":"provides a stronger capability of [[101feature:Interaction#Editing|editing]]",
	"description":"This feature covers the capability of [[#create|create]], [[#move|move]] and [[#delete|delete]] for the [[101companies:System]]. An [[:Category:101implementation|implementation]] of this feature provides certain abilities for the different capabilities:\n\n=== Create ===\n\n* Create a department within the company or as a subdepartment of another department in the company\n* Create an employee in a department\n\n=== Move ===\n\n* Move a department within the company to another parent, e. g. the company itself or another department\n* Move an employee to another department\n* Change the manager of a department\n\n=== Delete ===\n\n* Delete a department and its employees and subdepartments\n* Delete an employee\n\n[[Category:101capabilities]]",
	"implementations":[]
},
{
	"name":"Fault tolerance",
	"summary":"provide fault tolerance for services on companies",
	"description":"This feature covers the capability of [[fault tolerance]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"erlang"}]
},
{
	"name":"Interaction",
	"summary":"provide a user interface for operating on companies",
	"description":"This feature covers the capability of [[interaction]] for the [[101companies:System]]. \n\nThe following sections provide a requirement specification for a user interface.\n\nThe interface is likely to be a classic [[GUI]] or a web-based interface.\n\n=== Rationale ===\n\n* '''Simplicity''': The interface is supposed to be simple in that it is not meant to result in a GUI programming challenge. Anyone modestly familiar with a given GUI technology should be able to provide the GUI for the [[101companies:System]]. Anyone modestly familiar with the basic concepts of GUI programming should be able to understand the GUI part of the implementation without much effort. (Of course, some implementations will provide a GUI on top of a non-trivial architecture which will also affect the simplicity and understandability of the GUI.) Clearly, the GUI should be functionally correct and usable, but any form such as for appearance should be avoided in the interest of simplicity.\n\n* '''Data model-driven''': Companies are essentially hierarchical structures that break down into departments and employees. Hence, the GUI should provide views for companies, departments, and employees, and there should be navigation support to drill into companies and to return back to previous nodes in hierarchy. Each view must bind all data (properties) of the corresponding entity to appropriate GUI elements. Basic properties for names, addresses, and salaries should be editable. The state of navigation can be essentially viewed as a (possibly incomplete) path from the company root to an inner department or employee. Navigation may maintain this path like a stack.\n\n=== GUI views ===\n\nThere are views for all essential entities of the [[101companies:System]].\n\n* There is a ''Company'' view; this is also the initial view upon starting the GUI.\n* There is a ''Department'' view which is shown when (sub-) departments are selected in the ''Company'' or ''Department'' views.\n* There is an ''Employee'' view which is shown when employees (including managers) are selected in the ''Department'' view.\n\n=== Data binding ===\n\nLabels are shown in ''italics'' in the sequel.\n\nOrder of bindings per view suggest order in the actual layout.\n\n* The Company view:\n** A labeled, write-enabled text field for the ''Name'' of the company.\n** A labeled, listbox for the ''Departments'' of the company.\n* The Department view:\n** A labeled, write-enabled text field for the ''Name'' of the department.\n** A labeled, write-disabled text field for the name of the department's ''Manager''.\n** An ''Edit'' button is attached to the ''Manager'' field.\n** A labeled, listbox for the ''Employees'' of the company.\n** A labeled, listbox for the ''Sub-departments'' of the company.\n* The Employee view:\n** A labeled, write-enabled text field for the ''Name'' of the employee.\n** A labeled, write-enabled text field for the ''Address'' of the employee.\n** A labeled, write-enabled text field for the ''Salary'' of the employee.\n\n=== Editing ===\n\nThis section is limited to basic properties: names, addresses, salaries.\nTo get more information about further editing, look at [[101feature:Editing]].\n\nThe corresponding write-enabled text fields were identified above.\n\nAddition, removal, moving of departments and employees are not required.\n\nAn \"undo\" capability is also not required.\n\nThere are two options for committing changes from text fields to the underlying data (model):\n\n* ''Option 1 is to commit changes immediately'': this option is likely to be more reasonable for a classic, GUI-based standalone application. (For instance, a change event on a text field may be translated, perhaps with the help of a controller in the sense of MVC, into an actual property change on the data model.)\n* ''Option 2 is to commit changes when a \"Save\" button on the view is pushed'': this option may be more reasonable for a web-based application. (For instance, a web client may want to limit the communication with a server, and hence rely on an explicit \"Save\" action for the propagation of the data changes.)\n\n=== Navigation ===\n\nNavigation in the GUI is to be supported as follows:\n\n* The Company view:\n** The ''Close Window'' handler terminates the application. \n** When selecting a department from the ''Departments'' listbox, the corresponding Department view is invoked.\n* The Department view:\n** There is a ''Back'' button that navigates back to the previous view.\n** The ''Close Window'' handler copies the action of the ''Back'' button. \n** The ''Close Window'' terminates the application. \n** When pushing the ''Edit'' button (which is attached to the ''Manager'' field), the corresponding Employee view is invoked.\n** When selecting an employee from the ''Employees'' listbox, the corresponding Employee view is invoked.\n** When selecting a department from the ''Sub-departments'' listbox, the corresponding Department view is invoked.\n* The Employee view:\n** There is a ''Back'' button that navigates back to the previous view.\n** The ''Close Window'' handler copies the action of the ''Back'' button. \n\nAt any point, it should be possible to ''quit'' the application in a way that is in alignment with the OS\/GUI technology at hand.\n\n=== Operations ===\n\n[[101feature:Total]] and [[101feature:Cut]] are to be supported by the GUI as follows:\n\n* The Company view:\n** There is a labeled, write-disabled text field for the company's ''Total''.\n** A ''Cut'' button is attached to the ''Total'' field.\n* The Department view:\n** There is a labeled, write-disabled text field for the department's ''Total''.\n** A ''Cut'' button is attached to the ''Total'' field.\n* The Employee view:\n** A ''Cut'' button is attached to the ''Salary'' field.\n\n[[Category:101capabilities]]",
	"implementations":[{"name":"gwt"},
		{"name":"happstack"},
		{"name":"haskellCGI"},
		{"name":"html5XMLHttpRequest"},
		{"name":"html5ajax"},
		{"name":"html5indexedDatabase"},
		{"name":"html5local"},
		{"name":"html5session"},
		{"name":"html5tree"},
		{"name":"javaTree"},
		{"name":"jsf"},
		{"name":"qt"},
		{"name":"swing"},
		{"name":"webDSL"},
		{"name":"wp7"},
		{"name":"wxHaskell"},
		{"name":"zend"}]
},
{
	"name":"Logging",
	"summary":"log executions of operations or services on companies",
	"description":"This feature covers the capability of [[logging]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"aspectJ"},
		{"name":"haskellLogger"},
		{"name":"javaExorcism"}]
},
{
	"name":"Mapping",
	"summary":"mapping companies",
	"description":"This feature covers the capability of [[:Category:Mapping|mapping]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"haskellDB"},
		{"name":"hdbc"},
		{"name":"hxt"},
		{"name":"hxtPickler"}]
},
{
	"name":"Mentoring",
	"summary":"an association between mentees and mentors",
	"description":"* Each employee may have one associated mentor.\n* Each employee may have any number of associated mentees.\n* Mentors and mentees are employees (managers or not).\n* ''A'' is mentor of ''B'' if and only iff ''B'' is mentee of ''A''.\n* An employee cannot be a mentor of him- or herself.\n* Optional: If ''A'' is mentor of ''B'', then ''B'' must not be mentor of ''A''. \n\nThe mentoring feature is potentially interesting in so far that it implies a conceptual schema of companies that goes beyond tree shape. That is, while companies and department are decomposed in a tree-like manner, mentoring links may reach across the organizational structure. In some type systems, mentoring can be easily modeled. For instance, when composition and association relationships are distinguished (such as in UML-class diagrams), then mentees and mentors are modeled by associations. Also, in a programming language with references, mentor\/mentee relationships are easily modeled. It is usually sufficient to enable mentoring in a uni-directional manner such that only the direction from mentee to mentor is navigable. The mentoring feature is also interesting in so far that it involves specific constraints on the associated employees; they constraints need to be addressed by a sufficiently expressive constraint or type system or programmatically otherwise.\n\n[[Category:101extras]]",
	"implementations":[{"name":"emf"},
		{"name":"haskellParser"},
		{"name":"hibernate"},
		{"name":"jgralab"},
		{"name":"syb"}]
},
{
	"name":"Parallelism",
	"summary":"parallelize operations on companies",
	"description":"This feature covers the capability of [[parallelism]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"clojureRefs"},
		{"name":"dph"},
		{"name":"groovyDataFlowVariables"},
		{"name":"hadoop"},
		{"name":"jocamlJoinPatterns"},
		{"name":"scalaAkkaActors"}]
},
{
	"name":"Parsing",
	"summary":"provide a concrete syntax and parsing for companies",
	"description":"This feature covers the capability of [[parsing]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"antlrAcceptor"},
		{"name":"antlrObjects"},
		{"name":"antlrParser"},
		{"name":"antlrTrees"},
		{"name":"haskellParser"},
		{"name":"javaParseLib"}]
},
{
	"name":"Persistence",
	"summary":"persist companies",
	"description":"This feature covers the capability of [[persistence]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"cobol"},
		{"name":"ef"},
		{"name":"haskellDB"},
		{"name":"hdbc"},
		{"name":"hibernate"},
		{"name":"hibernate2"},
		{"name":"html5XMLHttpRequest"},
		{"name":"html5ajax"},
		{"name":"html5indexedDatabase"},
		{"name":"html5local"},
		{"name":"html5tree"},
		{"name":"jsf"},
		{"name":"seam"},
		{"name":"sqlServer"},
		{"name":"zend"}]
},
{
	"name":"Precedence",
	"summary":"a constraint on salaries to decrease with department nesting",
	"description":"A manager of any department or sub-department is required to receive a salary that is higher than the salaries of all employees of the department and all sub-departments. (It is clear that this constraint is not universally adopted by companies in practice.) The constraint is interesting in so far that many type systems will not be able to model this constraint directly, but instead the constraint may need to be enforced through contracts that explicitly traverse the company structure.\n\n[[Category:101extras]]",
	"implementations":[{"name":"html5ajax"},
		{"name":"html5tree"},
		{"name":"jsf"},
		{"name":"kiama"},
		{"name":"syb"},
		{"name":"zend"}]
},
{
	"name":"Serialization",
	"summary":"serialize (and deserialize) companies",
	"description":"This feature covers the capability of [[:Category:serialization]] for the [[101companies:System]]. \n\n[[Category:101capabilities]]",
	"implementations":[{"name":"antlrObjects"},
		{"name":"csharp"},
		{"name":"csharpLinqToXml"},
		{"name":"dom"},
		{"name":"emf"},
		{"name":"hadoop"},
		{"name":"haskell"},
		{"name":"haskellParser"},
		{"name":"hxt"},
		{"name":"hxtPickler"},
		{"name":"javaComposition"},
		{"name":"javaInheritance"},
		{"name":"javaLexer"},
		{"name":"javaParser"},
		{"name":"javaScanner"},
		{"name":"javaStatic"},
		{"name":"javaSyb"},
		{"name":"javaVisitor"},
		{"name":"javawsServer"},
		{"name":"jaxbChoice"},
		{"name":"jaxbComposition"},
		{"name":"jaxbExtension"},
		{"name":"jaxbSubstitution"},
		{"name":"jgralab"},
		{"name":"py3k"},
		{"name":"scala2"},
		{"name":"scalaXML"},
		{"name":"strutsAnnotation"},
		{"name":"strutsXml"},
		{"name":"swing"},
		{"name":"syb"},
		{"name":"xpathAPI"},
		{"name":"xsdClasses"},
		{"name":"xsdDataSet"},
		{"name":"xslt"}]
},
{
	"name":"Total",
	"summary":"an operation to total all salaries of employees",
	"description":"The operation for totaling salaries serves as a simple example of a [[query]] on company data such that all salaries are aggregated.",
	"illustration":"Let us illustrate the feature with a SQL query to be applied to an instance of a straightforward relational schema for companies.\nThe following query uses an inner SELECT statement to determine the company ''id'' from the company ''name'' \"meganalysis\",\nwith which, in turn, it selects all employees of the company and sums up their salaries. \n\n<syntaxhighlight lang=\"sql\">\nSELECT SUM(salary) FROM employee\n WHERE cid = \n  (SELECT id FROM company\n   WHERE name = \"meganalysis\");\n<\/syntaxhighlight>\nThe snippet originates from [[101implementation:mySql]].\n\n[[Category:101basics]]",
	"implementations":[{"name":"antlrLexer"},
		{"name":"antlrObjects"},
		{"name":"antlrTrees"},
		{"name":"aspectJ"},
		{"name":"clojureRefs"},
		{"name":"cobol"},
		{"name":"csharp"},
		{"name":"csharpLinqToXml"},
		{"name":"dom"},
		{"name":"dph"},
		{"name":"ef"},
		{"name":"emf"},
		{"name":"erlang"},
		{"name":"fsharp"},
		{"name":"groovyDataFlowVariables"},
		{"name":"gwt"},
		{"name":"hadoop"},
		{"name":"happstack"},
		{"name":"haskell"},
		{"name":"haskellCGI"},
		{"name":"haskellConcurrent"},
		{"name":"haskellDB"},
		{"name":"haskellLogger"},
		{"name":"haskellParser"},
		{"name":"hdbc"},
		{"name":"hibernate"},
		{"name":"hibernate2"},
		{"name":"html5XMLHttpRequest"},
		{"name":"html5ajax"},
		{"name":"html5indexedDatabase"},
		{"name":"html5local"},
		{"name":"html5session"},
		{"name":"html5tree"},
		{"name":"hxt"},
		{"name":"hxtPickler"},
		{"name":"javaComposition"},
		{"name":"javaExorcism"},
		{"name":"javaInheritance"},
		{"name":"javaLexer"},
		{"name":"javaMultithreading"},
		{"name":"javaParseLib"},
		{"name":"javaParser"},
		{"name":"javaRmi"},
		{"name":"javaScanner"},
		{"name":"javaStatic"},
		{"name":"javaSyb"},
		{"name":"javaTemplate"},
		{"name":"javaTree"},
		{"name":"javaVisitor"},
		{"name":"javawsServer"},
		{"name":"jaxbChoice"},
		{"name":"jaxbComposition"},
		{"name":"jaxbExtension"},
		{"name":"jaxbSubstitution"},
		{"name":"jdom"},
		{"name":"jgralab"},
		{"name":"jocamlJoinPatterns"},
		{"name":"jsf"},
		{"name":"kiama"},
		{"name":"py3k"},
		{"name":"qt"},
		{"name":"sax"},
		{"name":"scala"},
		{"name":"scala2"},
		{"name":"scalaAkkaActors"},
		{"name":"scalaXML"},
		{"name":"seam"},
		{"name":"seaside"},
		{"name":"silverlight"},
		{"name":"sqlServer"},
		{"name":"strutsAnnotation"},
		{"name":"strutsXml"},
		{"name":"swing"},
		{"name":"syb"},
		{"name":"wcf"},
		{"name":"wcfRest"},
		{"name":"webDSL"},
		{"name":"wp7"},
		{"name":"wxHaskell"},
		{"name":"xom"},
		{"name":"xpathAPI"},
		{"name":"xquery"},
		{"name":"xsdClasses"},
		{"name":"xsdDataSet"},
		{"name":"xslt"},
		{"name":"zend"}]
},
{
	"name":"Validation",
	"summary":"validate the user input against constraints",
	"description":"This feature covers the validation of user input against given constraints for the [[101companies:System]]. The following sections outline these constraints for every view (see [[101feature:Interaction]]) in the [[101companies:System]].\n\n=== Company ===\n\n* [[server-side]] validation:\n** The name of a company is unique concerning companies.\n* [[client-side]] validation:\n** The name of a company is not empty.\n\n=== Department ===\n\n* [[server-side]] validation:\n** The name of a department is unique concerning departments.\n* [[client-side]] validation:\n** The name of a department is not empty.\n\n=== Employee ===\n\n*[[server-side]] validation:\n** The combination of name and address is unique concerning employees.\n** The salary of an employee is less than the salary of his department manager.\n** The salary of an employee is less than the salaries of the employees of upper departments.\n** The salary of a department manager is less than the salaries of the employees of upper departments.\n** The salary of an employee is greater than the salaries of employees and managers of lower departments.\n** The salaries of all employees including managers are positive.\n* [[client-side]] validation:\n** A salary is a double value.\n** A salary is not empty.",
	"implementations":[{"name":"happstack"},
		{"name":"html5ajax"},
		{"name":"html5tree"},
		{"name":"jsf"},
		{"name":"zend"}]
},
{
	"name":"Visualization",
	"summary":"visualize company structure",
	"description":"The visualization feature covers the capability of [[visualization]] for the [[101companies:System]]. An example for visualization is a simple tree.",
	"implementations":[{"name":"html5tree"},
		{"name":"jgralab"}]
}
]
