[{
	"name":"antlrAcceptor",
	"summary":"parsing textual syntax with [[Technology:ANTLR]]",
	"motivation":"A concrete syntax for companies is defined \nusing the grammar notation of ANTLR \nso that a parser--in fact, an acceptor, can be generated.\nThe underlying grammar is LL(1).",
	"features":[{"name":"company"},
		{"name":"parsing"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"ANTLR"}],
	"usage":"See the the package ''org.softlang.tests'' for JUnit tests.\n\nThe Antlr tool (including parser generator and runtime) is included into the project.\nThere is a Makefile at the top of the project and within the org.softlang.antlr package.\nRun \"make\" at either of these locations to re-generate the parser.\nRefresh the project in Eclipse if you re-generated outside Eclipse.\nIn this manner, the parser is compiled.\n\nYou may also use an ANTLR IDE.\nhttp:\/\/antlrv3ide.sourceforge.net\/"
},
{
	"name":"antlrLexer",
	"summary":"tokenizing textual syntax with [[Technology:ANTLR]]",
	"motivation":"A lexer for companies is defined.\nThe lexer is, of course, oblivious to the precise structure of companies.\nSimple queries are expressible nevertheless.\nThat is, [[101feature:Total]] can be implemented by searching for number tokens.",
	"features":[{"name":"company"},
		{"name":"total"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"ANTLR"}],
	"usage":"See [[101implementation:antlrAcceptor]] for general instructions on the usage of ANTLR-based implementations."
},
{
	"name":"antlrObjects",
	"summary":"parsing textual syntax with [[Technology:ANTLR]] in [[Language:Java]]",
	"motivation":"An ANTLR-based parser for a concrete syntax of companies is provided.\nThe parser translates text into company objects.\nTo this end, a straightforward object model for companies is used.\n(In fact, the object model is very similar to the one of [[101implementation:javaComposition]].\nThe mapping is described by the semantic actions within the ANTLR-based parser description.\nThe underlying grammar is LL(1).\nBasic operations are implemented on top of the object model in basic OO programming style.\nPretty printing for the concrete syntax is also supported.\nHence, text-based serialization is fully enabled.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parsing"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"ANTLR"}],
	"illustration":"The following ANTLR production shows the syntax of departments---yet without semantic actions:\n\n<syntaxhighlight lang=\"antlr\">\ndept :\n  'department' STRING '{' \n    ('manager' employee)\n    ('employee' employee)* \n    dept*\n  '}';\n<\/syntaxhighlight>\nThat is, a department begins with the keyword \"department\", followed by a \n''STRING'' for the department's name, followed by a manager, which is an employee\nprefixed by the keyword \"manager\", followed by a sequence of \nemployees, finally, followed by a sequence of sub-departments. \nThe same production, with semantic actions for object synthesis included, looks as follows:\n\n<syntaxhighlight lang=\"antlr\">\ndept returns [Department d]:\n  { $d = new Department(); }\n  'department' name=STRING\n  { $d.setName($STRING.text); } \n  '{'\n    'manager' m=employee\n    { $d.setManager($m.e); }\n    ( 'employee' e=employee\n      { $d.getEmployees().add($e.e); }\n    )*\n    ( sub=dept\n      { $d.getSubdepts().add($sub.d); }\n    )*\n  '}'\n  ;\n<\/syntaxhighlight>\nThat is, semantic actions are enclosed into braces {...}, and they are placed in an appropriate positions\nof alternatives. The first semantic action constructs a department object; all subsequent actions populate the object.",
	"architecture":"See [[101implementation:antlrAcceptor]] for general instructions on the architecture of ANTLR-based implementations.\nThe object model for companies with methods for the basic operations is adopted from [[101implementation:javaComposition]].",
	"usage":"See [[101implementation:antlrAcceptor]] for general instructions on the usage of ANTLR-based implementations."
},
{
	"name":"antlrParser",
	"summary":"parsing textual syntax with [[Technology:ANTLR]]",
	"motivation":"A concrete syntax for companies is defined using the grammar notation of ANTLR \nso that a parser can be generated. [[101feature:Total]] is implemented by \nsemantic actions that aggregate the total in state of the parser object.",
	"features":[{"name":"company"},
		{"name":"parsing"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"ANTLR"}],
	"architecture":"See [[101implementation:antlrAcceptor]] for general instructions on the architecture of ANTLR-based implementations.",
	"usage":"See [[101implementation:antlrAcceptor]] for general instructions on the usage of ANTLR-based implementations."
},
{
	"name":"antlrTrees",
	"summary":"parsing textual syntax with [[Technology:ANTLR]]",
	"motivation":"Both concrete and abstract syntax is defined for companies.\nTo this end, we use an ANTLR-based parser description.\nThe abstract syntax is based on ANTLR's homogeneous tree format.\nThe resulting tree is walked with an ANTLR tree grammar to total all salaries or to cut salaries in half.",
	"features":[{"name":"company"},
		{"name":"parsing"},
		{"name":"total"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"ANTLR"}],
	"usage":"See [[101implementation:antlrAcceptor]] for general instructions on the usage of ANTLR-based implementations."
},
{
	"name":"aspectJ",
	"summary":"advanced modularization with [[Language:AspectJ]]",
	"motivation":"Concepts of [[aspect-oriented programming]] (say, advanced modularization) are put\nto work. The starting point is an [[object model]] for companies with properties\nbut no other instance methods. The basic operations are \nimplemented by adding the corresponding methods through [[inter-type declaration]]s\n\"after the fact\"---in an extra module. Such a modular development should be compared\nwith the simple approach of [[101implementation:javaComposition]] where\nall methods are readily implemented within the classes. Further, logging is supported \nby [[around advice]] on any call for cutting salaries.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"logging"}],
	"languages":[{"name":"AspectJ"}],
	"technologies":[{"name":"AJDT"},
		{"name":"ajc"}],
	"illustration":"The following [[Language:AspectJ]] aspect declares instance methods for\ncutting salaries on the classes of the object model for companies; the\nactual method bodies, which are elided, do not differ in any way from a \nstraightforward OO implementation:\n\n<syntaxhighlight lang=\"aspectj\">\npublic aspect Cut {\n   public void Company.cut() { ... }\n   public void Department.cut() { ... }\n   public void Employee.cut() { ... }\n}\n<\/syntaxhighlight>\nThe next goal is to log applications of cut so that the total of an \nobject is logged before and after applying ''cut''. The following fragment\nof a log illustrates the idea:\n\n<pre>\n...\n> BEGIN Cut Department \"Dev1.1\". Total: 4689.0\n> BEGIN Cut Employee \"Karl\". Total: 2345.0\n> END Cut Employee \"Karl\". Total: 1172.5\n> BEGIN Employee \"Joe\". Total: 2344.0\n> END Employee \"Joe\". Total: 1172.0\n> END Department \"Dev1.1\". Total: 2344.5\n...\n<\/pre>\n\nHence, the ''cut'' methods of company, department, and employee\nobjects should be intercepted. As a preparatory step, the design of\nthe object model is improved so that the pointcut can be expressed \nmore compactly with the help of [[interface polymorphism]]. That is,\nan interface for all common operations is introduced and implemented\n\"after the fact\" for all the types of the object model for companies:\n\n<syntaxhighlight lang=\"aspectj\">\npublic interface Operations {\n   String getName();\n   double total();\n   void cut();\n}\n\npublic aspect Polymorphism {\n   declare parents: Company implements Operations;\n   declare parents: Department implements Operations;\n   declare parents: Employee implements Operations;\n}\n<\/syntaxhighlight>\nIt remains to declare a pointcut for all calls of\n''cut'' and to advice each intercepted method call with logging\nactions before and after (say, around) it.\n\n<syntaxhighlight lang=\"aspectj\">\npointcut cut(Operations o):\n   target(o) && call(void Operations.cut());\n        \nvoid around(Operations o): cut(o) {\n   ... \/\/ Log \"before\" state\n   proceed(o);\n   ... \/\/ Log \"after\" state\n}\n<\/syntaxhighlight>",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]].\nThe Java classes of this object model do not implement any other features.\nPackage ''org.softlang.aspectj'' hosts aspects for [[101feature:Total]], \n[[101feature:Cut]], [[101feature:Depth]], and [[101feature:Logging]]. There is \nanother aspect ''Polymorphism'' which rehashes existing operations (getName,\ntotal, cut) as an interface [this!!org\/softlang\/features\/Operations.java Operations] on the relevant classes. Finally, \npackage ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project.\n* AJDT must be installed in Eclipse if Eclipse is to be used.\n* Open the project with Eclipse; this will also build the project.\n* There are JUnit tests available as the package ''org.softlang.tests''.\n* Run class ''Operations'' with JUnit to exercise several operations."
},
{
	"name":"atl",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"atl2",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"atl3",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"clojure",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"clojureRefs",
	"summary":"A [[Language:Clojure|Clojure]]-based implementation that uses [[Refs|transactional references]]",
	"motivation":"[[Language:Clojure|Clojure]] provides a number of interesting approaches to \nthe development with [[concurrency]]. One of these approaches is the use of \nprogrammable [[transactions]], analogous to [[database]] [[transactions]]. \nThis functionality is implemented by means of transaction-specific functions \nand references. To maintain a consistent memory state, \n[[Language:Clojure|Clojure]] relies on a [[Technology:STM|STM]]. This project \nis based on the implementation [[101implementation:clojure]] and changes it \nso that [[Refs]] and [[transactions]] are used.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parallelism"}],
	"languages":[{"name":"Clojure"}],
	"technologies":[{"name":"Eclipse"},
		{"name":"CounterClockwise"}],
	"illustration":"Changes to [[Refs]] by a transformation like [[101feature:Cut|Cut]] have to be\nencapsulated into a [[transaction]]. In [[Language:Clojure|Clojure]] the \nfunction ''dosync'' starts such a transaction allowing to alter [[Refs]] by \nan update function. \n\n <nowiki>\n(defn cutCompany [c]\n    (dosync\n        ;; alter ref function\n        (alter c #(update-in % [:depts] (partial map cutDept))))\n    ;; returning changed ref\n    c)\n<\/nowiki>",
	"architecture":"* ''company.clj'' definitions of the companies structure using clojure's defrecord\n* ''scenarios.clj'' functionalities: [[101feature:Cut|Cut]], [[101feature:Total|Total]]\n* ''meganalysis.clj'' a sample company (i.e. a [[Refs|Ref]] to a [[101feature:Company|company]])",
	"usage":"You need to install the [[Technology:Eclipse|Eclipse]] plugin [[Technology:CounterClockwise|CounterClockwise]]. \nUpdate Site: [http:\/\/ccw.cgrand.net\/updatesite]\n\nThen open ''meganalysis.clj'', hit \"run\" and excute the function you like:\n* ''(totalCompany meganalysis)'' \n* ''(cutCompany meganalysis)''"
},
{
	"name":"cobol",
	"summary":"a simple implementation in [[Language:Cobol]]",
	"motivation":"Cobol is a language that readily comes with means of data modeling and\nstorage (persistence). Hence, it provides a good fit for the basic features\nand persistence.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"persistence"}],
	"languages":[{"name":"Cobol 85"}],
	"technologies":[{"name":"OpenCOBOL"}],
	"architecture":"Directory hierarchy:\n* ''programs'': main Cobol programs for sample data and features\n* ''copybooks'': copybooks reused across the different programs\n* ''data'': location for keyed files\n* ''baselines'': baselines for automated test; see below",
	"usage":"There is a ''Makefile'' that exercises all features in some scripted order.\nAll programs are compiled with the OpenCobol compiler and executed with \nits runtime.",
	"issues":"It would be interesting to provide a Cobol-like user interface."
},
{
	"name":"csharp",
	"summary":"a simple implementation in [[Language:CSharp|C#]] for the [[Technology:.NET]] Framework",
	"motivation":"Basic style of [[OO programming]] is exercised. The C# type system is\nused to create an in-memory representation, in fact, an [[object model]] \nfor companies, departments, and employees. There is also an\nextra base class for persons from which employees are derived, thereby\nillustrating [[class inheritance]]. Operations on companies are\nimplemented as [[Category:instance method]]s. XML-based\n[[:Category:serialization]] is immediately available for all public\n[[Technology:.NET]] classes. Arguably, the generic [[O\/X mapping]]\nused for serialization produces XML that is not platform independent\nso that [[open serialization]] is supported.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"serialization"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"NUnit"},
		{"name":"Visual Studio"}],
	"architecture":"C# object-oriented representation of 101companies model is located in\nthe ''CompanyModel folder''. It contains classes with required\nproperties and methods (features implementations).\n\n''Tests'' folder contains:\n* ''FeaturesTest'' class which covers test cases for the features: [[:101feature:Total|Total]], [[:101feature:Cut|Cut]], [[:101feature:Depth|Depth]].\n* ''SerializationTests'' class which covers test cases for [[serialization]]\/de-serialization.\n\nAlso helpers for building in-memory model for meganalysis company and\nserialization are implemented.",
	"usage":"[[Technology:Visual Studio]] 2010 should be used to open a project\nfile. The project itself is a class-library and compiles into a\nDLL. To run a project you must execute at least one unit test (or all\nat once). The Nunit GUI could be used for executing the unit tests\nconveniently."
},
{
	"name":"csharpLinqToXml",
	"summary":"[[Technology:.NET]] Language Integrated Query usage for [[Language:XML]] processing ",
	"motivation":"Basic style of [[OO programming]] is applied. C# type system is used to create in-memory representation of the [[object model]].\n\nLINQ2XML is used for 2 scenarios:\n1. Reconstruct full in-memory model.\n2. Imlement operations directly on top of XMl file where the model is stored.\n\nTODO",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"serialization"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"NUnit"}],
	"architecture":"C# object-oriented representation of 101companies model iimlemented in [[101implementation:csharp]] is used. It contains classes with required properties and methods(features implementations).\nTODO\n1. manual reconsctruction of object model from xml\n2. transformations for pure xml model representation without using OO-model",
	"usage":"[[Technology:Visual Studio]] 2010 should be used to open a project file.\nThe project itself is a class-library and compiles into a DLL. To run a project you must execute at least one unit test (or all at once).\nNunit GUI or other Visual studio extension (e.g. Resharper) should be used for executing unit tests."
},
{
	"name":"dom",
	"summary":"[[in-memory XML processing]] with [[Technology:DOM]] in [[Language:Java]]",
	"motivation":"Companies are represented in [[Language:XML]] and the object model of [[Technology:DOM]] is used to\nrepresent and process XML documents [[In-memory XML processing|in memory]]. In particular, \noperations on companies are implemented in Java on top of DOM objects. Such objects are easily\nqueried---as needed for [[101feature:Total]]. DOM objects are also mutable---as needed for \nan [[Impure computation|impure]] implementation of [[101feature:Cut]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"Java"}],
	"technologies":[{"name":"JAXP"}],
	"illustration":"Consider the following DOM-based implementation of ''cut'':\n\n<syntaxhighlight lang=\"java\">\npublic class Cut {\n   public static void cut(Document doc) {\n      NodeList nodelist = doc.getElementsByTagName(\"salary\");\n      for (int i=0; i<nodelist.getLength(); i++) {\n         Element elem = (Element)nodelist.item(i);\n         double value = parseDouble(elem.getTextContent());\n         elem.setTextContent(Double.toString(value \/ 2));\n      }\n   }\n}\n<\/syntaxhighlight>\nThat is, the method receives an in-memory XML document which it queries with the\ndescendant axis (see ''getElementsByTagName'') so that all salary elements are collected\nin a ''NodeList'' which is processed by a regular loop such that the text content\nof each salary element is modified to reflect a cut in half.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations.",
	"issues":"* DOM-based validation shall be demonstrated some day."
},
{
	"name":"dph",
	"summary":"exercise [[Parallelism|data parallelism]] in [[Language:Haskell]] using [[Technology:DPH|Data Parallel Haskell]]",
	"motivation":"We exercise [[101feature:Parallelism|data parallelism]] in [[Language:Haskell]] ([[Technology:DPH]]). That is, we [[101feature:Total|total]] and [[101feature:Cut|cut]] salaries in a [[101feature:Company|company]] by making use of [[Parallel array|parallel arrays]] and DPH-specific functionality on these arrays.\nIn this context we also demonstrate some of DPH's (current) limitations (see illustration section for details):\n* The inability to mix [[Vectorisation|vectorised]] and non-vectorised code.\n* No vectorization support for user-defined types.\n* A DPH-specific [[Prelude]] with specific primitive types.\n* Data parallelism can only be applied to arrays.\nThe first two limitations force us to have both vectorised and non-vectorised modules, in which we define the company datatype.\nThe last limitation forces us to flatten the company to a list of salary values, which are of a DPH-float type, before salaries can be totaled and cut.\nThe resulting list of cut salary values has then to be \"reconsumed\" by the company in question.\nThese flatten\/consume and other conversion computations obviously take more time than we gain by switching to parallel salary functions, \nbut this implementation is supposed to demonstrate Haskell's data parallelism support rather than being about efficiency.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parallelism"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"GHC"},
		{"name":"GHCi"},
		{"name":"DPH"}],
	"illustration":"=== Cutting in Parallel ===\n\nAs we mentioned in the motivation section, data parallelism can only be applied to arrays.\nWe therefore flatten the company to become a list of salaries (see [this!!SalaryFlattener.hs] for details).\n\n==== Non-vectorised code ====\n\nUnfortunately the normal Prelude list type <syntaxhighlight lang=\"haskell\" enclose=\"none\">[a]<\/syntaxhighlight> is not supported in vectorised modules, but a special array type called <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray a<\/syntaxhighlight>. We therefore need a special function in a non-vectorised module for converting between <syntaxhighlight lang=\"haskell\" enclose=\"none\">[Float]<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray Float<\/syntaxhighlight> before we can cut in parallel:\n\n<syntaxhighlight lang=\"haskell\" source=\"dph\/Cut.hs\">\ncut :: Company -> Company\ncut c = (consumeSalaries c) (toList $ cutV $ fromList $ flattenSalaries c)\n<\/syntaxhighlight>\nWe first flatten the company, then convert the salary list to <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray Float<\/syntaxhighlight> and call the cut function <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutV<\/syntaxhighlight> from a vectorised module. After that we convert back to <syntaxhighlight lang=\"haskell\" enclose=\"none\">[Float]<\/syntaxhighlight> and call <syntaxhighlight lang=\"haskell\" enclose=\"none\">consumeSalaries<\/syntaxhighlight> to replace all salaries in the company tree.\n\n==== Vectorised code ====\n\nIn the vectorised module for cutting, where we want to work data parallel, we declare:\n\n<syntaxhighlight lang=\"haskell\" source=\"dph\/CutV.hs\">\n{-# LANGUAGE ParallelArrays #-}\n{-# OPTIONS_GHC -fvectorise #-}\n<\/syntaxhighlight>\nThis tells [[Technology:GHC]] to vectorise this module and that this module uses parallel arrays.\nWe then define the interface function between vectorised and non-vectorised code <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutV<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"dph\/CutV.hs\">\ncutV :: PArray Float -> PArray Float\n{-# NOINLINE cutV #-}\ncutV v = toPArrayP (cutVP (fromPArrayP v))\n<\/syntaxhighlight>\nThis function converts from <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray Float<\/syntaxhighlight> to a parallel array <syntaxhighlight lang=\"haskell\" enclose=\"none\">[:Float:]<\/syntaxhighlight>, calls the\nparallel code and converts back to <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray Float<\/syntaxhighlight>.\nA parallel array can only be used in a vectorised module, so only here can we convert to it. Marking this function <syntaxhighlight lang=\"haskell\" enclose=\"none\">{-# NOINLINE cutV #-}<\/syntaxhighlight> makes\nit usable in non-vectorised modules. <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutP<\/syntaxhighlight> calls the actual data parallel function <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutVP<\/syntaxhighlight>, which uses a parallel map function to cut all list values:\n\n<syntaxhighlight lang=\"haskell\" source=\"dph\/CutV.hs\">\ncutVP :: [:Float:] -> [:Float:]\ncutVP = mapP (\/2)\n<\/syntaxhighlight>",
	"architecture":"The module in [this!!SalaryFlattener.hs] contains functionality to flatten a company and to replace all salaries.\n[this!!Total.hs] and [this!!Cut.hs] host the code for converting between <syntaxhighlight lang=\"haskell\" enclose=\"none\">[Float]<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">PArray Float<\/syntaxhighlight> and calling data parallel functions for totaling and cutting salaries, which can be found in [this!!TotalV.hs] and [this!!CutV.hs].\nThe algebraic datatype for companies can be found in [this!!Company.hs]. [this!!SampleCompany.hs] holds a sample company.\n[this!!Main.hs] collects test scenarios for totaling and cutting.",
	"usage":"* All sources have to be compiled using the GHC-options <syntaxhighlight lang=\"make\" enclose=\"none\">-c -Odph -fdph-seq<\/syntaxhighlight>.\n* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline]. \nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"ef",
	"summary":"object [[persistence]] and [[O\/R mapping]] with [[Technology:.NET]] [[Technology:Entity Framework]]",
	"motivation":"Entity Framework object model is generated for SQL Server representation of 101companies model.  We use LINQ queries over entities to implement [[101feature:Total]], [[101feature:Cut]] and\n[[101feature:Depth]] features by showing different types of data tranformations happening on the database level. These transformations (SQL statements) are generated by [[Technology:Entity Framework]] using [[O\/R Mapping]]\nmetadata stored in [[Language:XML]] file, which was also automatically generated from the database 101companies model representation.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"persistence"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"Entity Framework"},
		{"name":"NUnit"},
		{"name":"SQL Server"}],
	"architecture":"CompanyModel.edmx represents all Entity Framework artifacts required for O\/R Mapping. This is an XML file contains:\n* SSDL content\n* CSDL content\n* C-S mapping content\n* EF Designer content\n<nowiki>and also a *.cs file with C# objects.<\/nowiki>\n\n<nowiki>*.edmx files are visualized in Entity Data Model Designer by default, but also can be opened as raw xml files.<\/nowiki>\nThe Entity Data Model Designer (Entity Designer) stores storage model information in an .edmx file at design time. \nAt build time the Entity Designer uses information in an .edmx file to create the .ssdl file that is needed by the Entity Framework at runtime.\n \nTests folder contains unit tests showing implemented features.",
	"usage":"[[101implementation:sqlServer]] should be evaluated as soon as current implementation requires [[101feature:Company]] to be created in the database.\n\n[[Technology:Visual Studio]] 2010 should be used to open a project file.\nThe project itself is a class-library and compiles into a DLL. To run a project you must execute at least one unit test (or all at once).\nNunit GUI or other Visual studio extension (e.g. Resharper) should be used for executing unit tests."
},
{
	"name":"emf",
	"summary":"[[M\/O mapping]] with [[Technology:EMF]]",
	"motivation":"[[M\/O mapping]] within the Java platform is exercised. The primary data model\nfor companies is an Ecore model from which an object model for \"Model Code\"\nin EMF's sense is derived. The classes of the Ecore-derived object model are\nsomewhat richer than [[POJO]], but their core properties and relationships\nare similar to a regular OO design (such as the one of\n[[101implementation:javaComposition]]), and operations on the EMF objects can \nbe implemented as [[:Category:instance method]]s on the Ecore-derived classes.\nIt should be noted that instance methods on generated classes survive \nre-generation because EMF is capable of distinguishing generated versus\nprogrammer-inserted class members. The Ecore model is interesting in so far that it\nclearly demonstrates the difference between [[Containment relationship|containment]]\nvs. [[reference relationship]]s. In particular, the association of mentees and mentores\nrequires a reference.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"mentoring"},
		{"name":"serialization"}],
	"languages":[{"name":"Ecore"},
		{"name":"Java"}],
	"technologies":[{"name":"EMF"}],
	"illustration":"Ecore supports modeling of structure. Ecore models are represented as XML documents.\nThe following excerpt shows the declaration of the \"classifier\" for companies: elements in \nthe Ecore-specific namespace are used to break down companies into a name and \na list of departments:\n\n<syntaxhighlight lang=\"xml\">\n<eClassifiers xsi:type=\"ecore:EClass\" name=\"Company\">\n  <eStructuralFeatures xsi:type=\"ecore:EAttribute\" name=\"name\"\n    ordered=\"false\" lowerBound=\"1\"\n    eType=\"ecore:EDataType http:\/\/www.eclipse.org\/emf\/2002\/Ecore#\/\/EString\"\/>\n  <eStructuralFeatures xsi:type=\"ecore:EReference\" name=\"depts\"\n    ordered=\"false\" upperBound=\"-1\" \n    eType=\"#\/\/Department\" containment=\"true\"\/>\n<\/eClassifiers>\n<\/syntaxhighlight>\nThe Ecore-derived, Java-based object model will not be illustrated here because it covers \nproperties and relationships that are similar to a regular OO design, and all additional fields\nand methods are not used in the basic scenario at hand. \n\nObjects of the Ecore-derived model can also be serialized to or de-serialized from XML (XMI).\nTo this end, the namespace for the model and its implementing package need to be registered \nwith the ''registry of EMF's EPackage''. Thus:\n\n<syntaxhighlight lang=\"java\">\nEPackage.\n  Registry.\n  INSTANCE.\n  put(CompanyPackage.eNS_URI, CompanyPackage.eINSTANCE);\n<\/syntaxhighlight>\nFurther, a specific serialization format has to be chosen. To this end, a number of idiosyncratic \nobjects have to be constructed and configured so that a preferred file extension is mapped to \nthe intended serialization behavior. For instance, the process of loading a company from an \".xmi\"\nfile is organized as follows:\n\n<syntaxhighlight lang=\"java\">\nResourceSet resourceSet = new ResourceSetImpl();\nresourceSet.\n  getResourceFactoryRegistry().\n  getExtensionToFactoryMap().\n  put(\"xmi\", new XMIResourceFactoryImpl());\nResource xmiResource = \n  resourceSet.\n  createResource(URI.createFileURI(\"sampleCompany.xmi\"));\nxmiResource.load(null);\nCompany c = (Company)xmiResource.getContents().get(0);\n<\/syntaxhighlight>",
	"architecture":"=== Summary ===\n\nFile ''model\/Company.ecore'' is the Ecode model of companies. File ''model\/Company.genmodel'' is the EMF generator model which has been derived from the Ecore model; see below. Files ''model\/Company*.xsd'' are XML schemas for XML instances of the Ecore model; they were derived with the Export functionality from the generator model; see below. Package ''company'' and subpackages contain the model code for companies. Most of this code has been generated from the generator model (see below) but the generated code has been enriched with instance methods for [[101feature:Total]] and [[101feature:Cut]]. (We leverage the EMF convention that all generated members are marked by @generated whereas the manually injected members do not carry such markers. In this manner the model code can be regenerated without overriding manually injected members.) Package ''org.softlang.features.Serialization'' contains boilerplate code for serialization. Package ''org.softlang.tests'' contains JUnit tests for operations on companies and serialization.\n\n=== Transcript ===\n\nCreation and evolution of an EMF project with support for serialization is not straightfoward.\n\nThe following transcript documents the essential steps and constraints.\n\n==== Create EMF Project ====\n\n* -> New -> Empty EMF Project ...\n\n==== Create Ecore Model ====\n\n* -> New -> Ecore Model \n* Choose the \"model\" folder of the EMF project.\n* Adjust name of model (default My.ecore) if needed.\n* Now it is time to work out the Ecore model.\n* One needs to define name of the package, namespace URI, and prefix.\n\nA minimal example follows:\n\n<syntaxhighlight lang=\"xml\">\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ecore:EPackage xmi:version=\"2.0\"\n    xmlns:xmi=\"http:\/\/www.omg.org\/XMI\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n    xmlns:ecore=\"http:\/\/www.eclipse.org\/emf\/2002\/Ecore\" name=\"foo\"\n    nsURI=\"www.foo.com\" nsPrefix=\"bar\">\n  <eClassifiers xsi:type=\"ecore:EClass\" name=\"xyz\"\/>\n<\/ecore:EPackage>\n<\/syntaxhighlight>\n==== Create EMF Generator Model ====\n\n* Select the Ecore model in the package explorer.\n* -> New -> Generator model \n* Choose the \"model\" folder of the EMF project.\n* When asked for a Model Importer, choose Ecore Model.\n* When asked for Model URIs, '''you must Browse Workspace, and select the Ecore file'''.\n\n==== Generate Model Code ====\n\n* Open the generator model.\n* Right click on it in the opened view.\n* -> Generate Model Code\n\nThis will generate several files and folders:\n* build.properties\n* plugin.properties\n* plugin.xml\n* src\/<your-ecore-name>\n* src\/<your-ecore-name\/impl>\n* src\/<your-ecore-name\/util>\n\n==== Enable XMI\/XML resources ====\n\n* Open ''plugin.xml'' with ''plug-in manifest editor''.\n* Select ''Dependencies'' tab.\n* Add ''org.eclipse.emf.ecore.xmi.impl'' to ''imported packages''.",
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in package ''org.softlang.tests''.\n* If you change the Ecore or generator models, you may need to rerun some EMF tools; see the transcript above.",
	"issues":"* Use case for EMF somewhat trivial; one should make use of richer API (design patterns)."
},
{
	"name":"erlang",
	"summary":"an Erlang-based implementation ",
	"motivation":"Concurrency is implemented in a simple way. The company itself is a server process with which you communicate through an API (meganalysis for now). If that process has a bug, it crashes, but a supervisor will restart it back up (though it does not yet persist its state under crashes). Thus, it is already an example of fault tolerance as well, albeit naively implemented.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"fault tolerance"}],
	"languages":[{"name":"Erlang"}],
	"technologies":[{"name":"Erlang\/OTP"},
		{"name":"GNU make"},
		{"name":"Rebar"}],
	"architecture":"The code makes extensive use of the OTP (Open Telecom Platform). Aptly misnamed, this is a library of common concurrency tasks which most concurrent programs will use. Rather than writing code that uses the primitive send (''!'') and receive (''receive .. end'') constructs, these are wrapped in OTP.\n\nA common OTP idiom is that OTP provides a *generic* version of a task, a server, a supervisor, and so on. This generic version is then specialized by injecting the name of a module. Whenever specific hook points in the generic server is reached, a callback is made to the module according to a protocol. Thus our code is call-backed to handle the specialization. A consequence as that we don't have to handle all the gritty parts of message passing concurrency.\n\nThe code consist of several modules:\n\n* ''meganalysis.app.src'': This file describes a manifest of the meganalysis application.\n\n* ''meganalysis_app'': A callback interface to the generic ''application'' system in OTP. An application is a collection of processes that so some task together. The Erlang VM is an application server in which you store several applications. Should we want to provide a web interface for instance, we can spawn a webserver application later.\n\n* ''meganalysis_sup'': Provides the callbacks for the generic ''supervisor'' construction. The supervisor is built to mostly live in hibernation supervising concrete workers. If the worker dies due to a program error or some unforseen event, then the supervisor will restart its worker according to some rules. We use the ''one_for_one'' strategy here, but there are several possible. If the worker crashes too often however, the supervisor itself dies. This trigger application death in our case, but usually a nested tree of supervisors can withstand supervisor crashes as the error usually only propagates up the tree to a certain point.\n\n* ''meganalysis_process'': A generic server implementation. That is, we provide a set of callbacks for the ''gen_server'' OTP generic server *behaviour*. Note that we export a neat interface which hides the ''gen_server'' parts. Specifically, we export ''total()'' and ''cut()''. Total is a *call* meaning that it is synchronous. A caller will wait on the server to return an answer. Cut is a *cast* on the other hand. It is asynchronous and the caller is not going to wait on its completion. The ''handle_*'' parts are the protocol for the ''gen_server'' callbacks. That is actually doing the meat of the work.\n\n* ''meganalysis'': It is common to provide a nice API to the rest of the Erlang system, to hide the complexities of processes. An user of the application will only use this API to work with the application. Thus, we decouple the internal design of the application with its interface.",
	"usage":"=== Prerequisites ===\n\nFirst, in order to run this code, you need three tools:\n\n* Make, preferably GNU make, though the makefile should be BSD-make compatible. It can be skipped if you want. The Makefiles only serves as a canonical interface that makes Emacs and Vim's build-triggers work nicely.\n\n* A Recent Erlang\/OTP distribution. Tested with R14B02, but anything from R13B04 and up ought to work for this. Avoid R14A if possible. It is a beta-release.\n\n* [[Technology:Rebar]]: Rebar is an Erlang build tool. When rebar has been boot-strapped, you place it into your path after which you have access to a build system that is bearable to work with.\n\n=== Building ===\n\nOnce the above requirements are satisfied, the code can be built with\n\n<pre>\n     make compile\n<\/pre>\n\nIt should complete with no warnings.\n\n=== Testing ===\n\nTo test the code, we use\n\n<pre>\n     make console\n<\/pre>\n\nwhich will spawn a console in the Erlang system, but with an altered code-load path so it can find our compiled bytecode .beam files. Now you can test it by:\n\n<pre>\n     1> meganalysis:run(). % Press return here :)\n     {399747,199873.5}\n     2> q().\n     ok\n<\/pre>\n\nNote the '.', which marks the end of the expression to the parser."
},
{
	"name":"fsharp",
	"summary":"A simple implementation in [[Language:FSharp|F#]] for the [[Technology:.NET]] Framework",
	"motivation":"Multiparadigm nature of F# is shown;\nboth OO and FP features of the languages are illustrated by adjusting a basic [[101implementation:csharp | C#]] implementation.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"FSharp"}],
	"technologies":[{"name":"fcs.exe"},
		{"name":".NET"},
		{"name":"NUnit"},
		{"name":"Visual Studio"}],
	"illustration":"<syntaxhighlight lang=\"fsharp\">\n    type Company() = \n     class\n       let mutable name = \"\"\n       let mutable departments:List<Department> = new List<Department>() \n  \n       member this.Name with get() = name and set v = name <- v\n       member this.Departments with get() = departments and set v = departments <- v\n<\/syntaxhighlight>\n\nHere we define a member which is essentially a wrapper around pure functional style of calculating total using accumulator. (''fold'' function from F# library is used)\n\n<syntaxhighlight lang=\"fsharp\">\n member this.TotalSalaries =\n        let x = List.fold (fun (acc) (elem:Department) -> acc + elem.Total) 0M (List.ofSeq departments)\n        x\n\n<\/syntaxhighlight>",
	"architecture":"",
	"usage":"To make NUnit GUI working with .NET 4.0\nUnder <configuration> add:\n<nowiki>\n\n<startup>\n  <supportedRuntime version=\"v4.0.30319\" \/>\n<\/startup>\n<\/nowiki>\n\nand under <runtime> add:\n<loadFromRemoteSources enabled=\"true\" \/>"
},
{
	"name":"groovyDataFlowVariables",
	"summary":"A [[Language:Groovy|Groovy]]-based implementation that uses [[data flow variables]]",
	"motivation":"[[Language:Groovy|Groovy]] is one of the most well-known [[JVM languages]]. \nOne of its strength lies in the [[Technology:GPars|GPars]] [[Category:Framework|framework]], \nwhich offers many different approaches to [[parallel programming]]. An \ninteresting concept is the [[concurrency]] based on [[data flow]]. The overall \nidea is the creation of a temporal order between processes, seeing the availability \nof certain values as [[constraints]]. This project demonstrates the usage of \nthis [[data flow]] [[concurrency]] in [[Language:Groovy|Groovy]] using [[data flow variables]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parallelism"}],
	"languages":[{"name":"Groovy"}],
	"technologies":[{"name":"Eclipse"},
		{"name":"Groovy-Eclipse"},
		{"name":"GPars"},
		{"name":"JUnit"}],
	"illustration":"Queries like [[101feature:Total|Total]] depends on different values (e.g. \nthe [[101feature:Total|total]] of each department). Because these subqueries \nare independent from each other they can be executed in parallel.\n\nIn general, all subcomputations are outsourced in a new [[thread]]. Therefore, \nthese computations are encapsulated into [[Closure|closures]] and transfered \nto the ''task'' method. If such a [[thread]] needs a value of a [[data flow variables|data flow variable]], \nwhich is not bound (i.e. computed) yet, it is [[wait|suspended]] until its [[notify all|awoken]] \nby the system. For compact programing [[Technology:GPars|GPars]] offers a \n[[container]] like [[bean]], which properties are [[data flow variables]]. \nThese variables are initialized [[Lazy Evaluation|lazily]] the first time they are accessed. \nAn example for such a [[bean]] is ''totals''.\n\n <nowiki>\n\/\/ outsourcing total computation for each the department\ndepts.each() { d ->\n    task {\n    \/\/ adding dept's total as dataflow variable to the bean\n        totals.putAt d.name, d.total()\n    }\n}\n<\/nowiki>",
	"architecture":"* ''Company.groovy'' everything related to a company\n* ''Department.groovy'' everything related to a department\n* ''Employee.groovy'' everything related to an employee\n* ''Basic.groovy'' basic functionality tests with a sample company",
	"usage":"You need to install the [[Technology:Eclipse|Eclipse]] plugin [[Technology:Groovy-Eclipse|Groovy-Eclipse]].\nUpdate Site: [http:\/\/dist.springsource.org\/release\/GRECLIPSE\/e3.7\/]\n\nThen open ''Basic.groovy'' and start the [[Technology:JUnit|JUnit]] test case you like."
},
{
	"name":"gwt",
	"summary":"[[web programming]] with [[Technology:GWT]]",
	"motivation":"The present project provides a simple [[Web Application|WebApp]] for companies by making use of the [[Technology:GWT| Google Web Toolkit]] and therefore [[Technology:Ajax]]. \nVia [[asynchronous communication]] the server provides functionality for cutting and totaling salaries.\nThe server allows the client to retrieve instances of [[Serialization|serializable]] classes of the company's [[object model]].\nThe client presents the provided functionality and retrieved data via predefined [[GUI]] components.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"distribution"}],
	"languages":[{"name":"Java"},
		{"name":"Javascript"},
		{"name":"HTML"},
		{"name":"XML"},
		{"name":"CSS"}],
	"technologies":[{"name":"GWT"}],
	"architecture":"'''Client''': \nClient classes are to be found in the client package. See ''org.softlang.client''.\nThere is the GUI and a special [[101feature:Company]] object model for the client with classes that support [[101feature:Serialization]]. See ''org.softlang.client.company'' for the latter.\nThis object model holds \"shallow\" data for the widgets. The entry point for the client is the [this!!src\/org\/softlang\/client\/Gwt.java Gwt.java] class.\nHere we describe the app's client side appearance and functionality.\n\n'''Server''': \nServer classes are to be found in the server package. See ''org.softlang.server''. \nWe use an object model for [[101feature:Company]] very much like in project [[101implementation:java]]\n(We use a cloned object model for the sake of a simple build for this GWT project.)\nThe server maintains an index (see class [this!!src\/org\/softlang\/server\/Index.java Index.java]) between shallow and proper objects.\nThat is, departments and employees are identifiable by their ids (say, names).\n \nThe communication between client and server is modeled by the [this!!src\/org\/softlang\/client\/Service.java Service] interface. See the client package.\nThere is also the asynchronous version of it: [this!!src\/org\/softlang\/client\/ServiceAsync.java ServiceAsync.java]. \nThese services allow the client to load and save data and perform scenarios [[101feature:Total]] and [[101feature:Cut]].",
	"usage":"* To run a demo:\n** compile [this!!src\/org\/softlang\/client\/Gwt.java org.softlang.client.Gwt] (click the red GWT icon).\n** run [this!!src\/org\/softlang\/server\/ServiceImpl.java org.softlang.server.ServiceImpl].\n** open http:\/\/localhost:8888 in your browser.\n* The server runs until is terminated explicitly in the eclipse console.\n\n[[Category:Web application]]"
},
{
	"name":"hadoop",
	"summary":"parallel processing with [[Technology:Hadoop]]",
	"motivation":"Companies are processed in parallel manner according to the [[MapReduce]] programming \nmodel. To this end, primitive data of companies, departments, and employees can be stored\nin [[file]]s of fixed-size [[record]]s in a [[:Category:distributed file system]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"},
		{"name":"parallelism"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"Hadoop"}],
	"illustration":"While data is stored in files, the records can be de-serialized into objects\nfor the convenience of MapReduce functionality. For instance, an object type for\nemployees is designed as follows:\n\n<syntaxhighlight lang=\"java\">\nclass Employee\n   implements WritableComparable<Employee> {\n\n\tprivate Text name;\n\tprivate Text address;\n\tprivate DoubleWritable salary;\n\tprivate Text company;\n\n   \/\/ getters, setters and omitted\n    \n   public void readFields(DataInput in)\n         throws IOException {\n      name = new Text();\n      name.readFields(in);\n      address = new Text();\n      address.readFields(in);\n      ...\n   }\n}\n<\/syntaxhighlight>\nThat is, there are properties for name, address, and salary---as usual. In\naddition, there is a property for the the company so that the company of each\nemployee is immediately known without any traversal or state-based effort. \nObjects are populated from records on file through a ''readFields'' method\nthat is required for any deserializable type.\n\nA MapReduce computation consists of a mapper and a reducer. The \nessential methods of these components, i.e., methods ''map'' (extraction)\nand ''reduce'' (aggregation) are shown below:\n\n<syntaxhighlight lang=\"java\">\nprotected void map(\n   Text key, Employee value, Context context)\n   throws ... {\n      context.write(\n         value.getCompany(),\n         value.getSalary());\n}\n<\/syntaxhighlight>\n<syntaxhighlight lang=\"java\">\nprotected void reduce(\n   Text key, Iterable<...> values, Context context)\n   throws ... {\n      double total = 0;\n      for(DoubleWritable value: values)\n         total += value.get();\n      context.write(key, new DoubleWritable(total));\n}       \n<\/syntaxhighlight>\nThat is, the ''map'' method constructs an intermediate key-value\npair from each employee such that the company of an employee \n(say, the company name) serves as key and the employee's salary\nserves as value. In this manner, the MapReduce framework will correctly group\ntogether all salaries per company. Hence, the ''reduce'' method\nsimply iterates over all salaries, grouped by key, and sums them \nup by a trivial aggregation loop so that a pair of the company key \nwith the total of salaries is written to the output file.",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]].\nPackage ''org.softlang.operations'' hosts designated classes with static methods for\nthe MapReduce jobs [[101feature:Total]] and [[101feature:Cut]]. Some boilerplate code for \n[[101feature:Serialization]] is implemented in the class ''org.softlang.company.Company'' \n(see methods ''readObject'' and ''writeObject''). Package ''org.softlang.tests'' \nhosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* The default settings runs Hadoop on your local machine. For distributed setup see below.\n* There are JUnit tests available as the package ''org.softlang.tests''.\n** Run class ''Serialization'' with JUnit to create and serialize an example Company.\n** Run class ''Basics'' with JUnit to exercise basic features."
},
{
	"name":"happstack",
	"summary":"[[Web programming]] with [[Technology:Happstack]] in [[Language:Haskell]] ",
	"motivation":"This implementation provides a small C\/S [[Web Application|web application]] written with the help of the [[Technology:Happstack]] [[:Category:Framework|framework]]. We exercise the use of [[Routing filter|routing filters]] to filter requests by action: A user can either view a specific part of a [[101feature:Company|company]], [[101feature:Cut|cut]] a specific part or save a company component after manipulation of primitive fields.\nThe company is stored in a client-side [[Cookie|cookie]].\nThe part to be viewed, cut or saved is specified by making use of the [[Zipper]] inspired focus concept (see the [[101implementation:wxHaskell|wxHaskell]] implementation for details).\nWe also demonstrate [[101feature:Validation|validation]]: When processing a save-request, sent by an HTML form, the server applies various validators to eventually return error messages, which will be displayed to the user in the [[Browser|browser]]. As a response the client receives HTML documents, which are composed by making use of the [[Technology:Heist]] [[Language:XHTML|XHTML]] templating engine.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"distribution"},
		{"name":"validation"}],
	"languages":[{"name":"Haskell"},
		{"name":"JavaScript"},
		{"name":"XHTML"},
		{"name":"CSS"}],
	"technologies":[{"name":"GHC"},
		{"name":"Happstack"},
		{"name":"Heist"}],
	"illustration":"In the following we will demonstrate how a specific request is processed by the server.\n\n=== Saving an Employee ===\n\n'''Scenario:''' After requesting to view a manager the user manipulates the input fields and submits a request by clicking a save button.\nThe browser sends an HTTP-request together with a company-cookie to the server. The URL looks like this:\n\n''<nowiki>http:\/\/localhost:8000\/Employee\/Save\/ManagerFocus%20[0]\/?Name=Erik&Address=<\/nowiki>''\n\n''<nowiki>Utrecht&Salary=1234.0<\/nowiki>''\n\n==== Routing filter ====\n\nWe set up a simple HTTP server:\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Main.hs\" line>\nmain = simpleHTTP nullConf $ \n  msum [ path $ \\v -> path $ \\a -> path $ \n           \\f -> mainPart a v f\n       , serveDirectory EnableBrowsing [] \"static\"]   \n<\/syntaxhighlight>\nWe specify two possible server behaviours (values of <syntaxhighlight lang=\"haskell\" enclose=\"none\">ServerPartT<\/syntaxhighlight>) in a list, which we then apply to the <syntaxhighlight lang=\"haskell\" enclose=\"none\">MonadPlus<\/syntaxhighlight>-function <syntaxhighlight lang=\"haskell\" enclose=\"none\">msum<\/syntaxhighlight>. This function tries to run each server until one serverstart succeeds.\nThe first list element uses Happstack's <syntaxhighlight lang=\"haskell\" enclose=\"none\">path<\/syntaxhighlight> function to extract:\n\n* The view (here <syntaxhighlight lang=\"haskell\" enclose=\"none\">Employee<\/syntaxhighlight>)\n* The action (here <syntaxhighlight lang=\"haskell\" enclose=\"none\">Save<\/syntaxhighlight>)\n* The focus (here <syntaxhighlight lang=\"haskell\" enclose=\"none\">ManagerFocus [0]<\/syntaxhighlight>)\nIn case the extraction fails the server falls back to being a file server in line 4.\nIn case extraction succeeds <syntaxhighlight lang=\"haskell\" enclose=\"none\">mainPart<\/syntaxhighlight> is called passing the action, the view and the focus:\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Serverparts.hs\">\nmainPart :: Action -> View -> Focus -> ServerPartT IO Response\nmainPart View = viewPart\nmainPart Cut  = cutPart\nmainPart Save = savePart   \n<\/syntaxhighlight>\nIn this scenario <syntaxhighlight lang=\"haskell\" enclose=\"none\">mainPart<\/syntaxhighlight> matches on <syntaxhighlight lang=\"haskell\" enclose=\"none\">Save<\/syntaxhighlight> and calls \n<syntaxhighlight lang=\"haskell\" enclose=\"none\">savePart<\/syntaxhighlight> passing the view and the focus:\n\n==== Saving ====\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Serverparts.hs\" line>\nsavePart :: View -> Focus -> ServerPartT IO Response\nsavePart v f = do\n  s <- save\n  case s of\n    (Left errs) -> do\n      c <- readCCookie\n      displayPart v f c errs\n    (Right newc) -> displayPart v f newc []       \n    where\n      save = case v of\n        CompanyV  -> saveCompany f\n        DeptV     -> saveDepartment f\n        EmployeeV -> saveEmployee f \n<\/syntaxhighlight>\nThe function starts by calling a save function, which is chosen based on the given <syntaxhighlight lang=\"haskell\" enclose=\"none\">View<\/syntaxhighlight> value. The <syntaxhighlight lang=\"haskell\" enclose=\"none\">save<\/syntaxhighlight>-functions, which are all of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Focus -> ServerPartT IO (Either [(ENames,String)] Company)<\/syntaxhighlight> either return a list of error information or the new company. In case of errors <syntaxhighlight lang=\"haskell\" enclose=\"none\">savePart<\/syntaxhighlight> calls <syntaxhighlight lang=\"haskell\" enclose=\"none\">displayPart<\/syntaxhighlight> in line 7 passing the old company (read from the cookie) and the errors. In case of success the new company and an empty list of errors is passed to <syntaxhighlight lang=\"haskell\" enclose=\"none\">displayPart<\/syntaxhighlight> in line 8. \nIn this scenario  <syntaxhighlight lang=\"haskell\" enclose=\"none\">saveEmployee<\/syntaxhighlight> is called by <syntaxhighlight lang=\"haskell\" enclose=\"none\">savePart<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Save.hs\" line>\nsaveEmployee :: Focus -> ServerPartT IO (Either [(ENames,String)] Company)\nsaveEmployee f = do\n  c <- readCCookie\n  name <- look \"Name\"\n  address <- look \"Address\"\n  salary <- lookRead \"Salary\"\n  let newe = Employee name address salary\n  let ev = validateEmployee c f newe\n  case ev of\n    (Just errs)\n        -> return $ Left errs\n    Nothing\n        -> do\n            let newc = writeEM f c newe\n            addCookie Session $ \n              (mkCookie \"company\" (show newc))\n            return $ Right newc\n<\/syntaxhighlight>\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">saveEmployee<\/syntaxhighlight> reads the company from a cookie and extracts the request parameters from the URL in lines 3-6. These values are used to compose the new <syntaxhighlight lang=\"haskell\" enclose=\"none\">Employee<\/syntaxhighlight> value in line 7. \nIn line 8 this employee is then passed to the validation function <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateEmployee<\/syntaxhighlight> of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Company -> Focus -> a -> Maybe [(ENames,String)]<\/syntaxhighlight>. If the validation succeeds, <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateEmployee<\/syntaxhighlight> returns <syntaxhighlight lang=\"haskell\" enclose=\"none\">Nothing<\/syntaxhighlight>. In this case the employee is replaced within the company, which is then re-stored in the cookie and returned by the function (lines 14-16). Otherwise <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateEmployee<\/syntaxhighlight> returns error information, which is then also returned by <syntaxhighlight lang=\"haskell\" enclose=\"none\">saveEmployee<\/syntaxhighlight> in line 11.\n\n==== Validation ====\n\nThe validation functionality can be found in the ''Validators'' module:\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Validators.hs\">\nvalidateEmployee :: Validations Employee\nvalidateEmployee c f (Employee n a s) = if null vs \n                           then Nothing\n                           else Just $ concat vs \n                             where \n                               vs = catMaybes \n                                [ validateNA c f (n,a)\n                                , validateSalary c f s]\n<\/syntaxhighlight>\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">validateEmployee<\/syntaxhighlight> composes two validations (see [this!!Validators.hs] for details):\n* <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateNA<\/syntaxhighlight> checks whether the employee's name\/address pair is unique in the company <syntaxhighlight lang=\"haskell\" enclose=\"none\">c<\/syntaxhighlight>.\n* <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateSalary<\/syntaxhighlight> checks two things regarding the employee's salary:\n** It checks whether by changing the salary the employee's department-manager still receives the highest salary within the department.\n** It checks whether the salary has a positive value.\nIn case both validations return <syntaxhighlight lang=\"haskell\" enclose=\"none\">Nothing<\/syntaxhighlight>, <syntaxhighlight lang=\"haskell\" enclose=\"none\">validateEmployee<\/syntaxhighlight> returns <syntaxhighlight lang=\"haskell\" enclose=\"none\">Nothing<\/syntaxhighlight>. Otherwise it returns the list of all error messages.\n\n==== Binding and Responding ====\n\nThe user might have tried to assign an invalid salary and an invalid name\/address pair to the manager in question. Validation therefore would return error information. \n<syntaxhighlight lang=\"haskell\" enclose=\"none\">savePart<\/syntaxhighlight> would call <syntaxhighlight lang=\"haskell\" enclose=\"none\">displayPart<\/syntaxhighlight> passing the old company and the error messages:\n\n<syntaxhighlight lang=\"haskell\" source=\"happstack\/Serverparts.hs\" line>\ndisplayPart :: View -> Focus -> Company -> [(ENames,String)] -> ServerPart Response\ndisplayPart v f c errs = do \n      td <- newTemplateDirectory' tDir $ \n              eNamesBinder errs $ binder f c $ \n                emptyTemplateState tDir\n      render td (B.pack tname)\n          where\n            binder = case v of\n              CompanyV  -> companyBinder\n              DeptV     -> departmentBinder\n              EmployeeV -> employeeBinder\n                where\n            tname = case v of\n              CompanyV  -> \"company\"\n              DeptV     -> \"department\"\n              EmployeeV -> \"employee\"\n<\/syntaxhighlight>\nIn lines 8-16 <syntaxhighlight lang=\"haskell\" enclose=\"none\">displayPart<\/syntaxhighlight> decides which template and which binder to apply by making use of a <syntaxhighlight lang=\"haskell\" enclose=\"none\">case<\/syntaxhighlight> expression on the given view. The binder will bind all template variables to strings or small HTML fragments (splices). After that <syntaxhighlight lang=\"haskell\" enclose=\"none\">eNamesBinder<\/syntaxhighlight> will bind the error messages to template variables. Both binders can be found in [this!!Binder.hs]. \nThey return a function of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Monad m => TemplateState m -> TemplateState m<\/syntaxhighlight>. That is, binders are state transformers for templates.\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">displayPart<\/syntaxhighlight> then renders the HTML document, which is sent to the client as the response in line 6.",
	"architecture":"[this!!Main.hs] holds the server using various server parts in [this!!Serverparts.hs]. The actual save action is performed by functionality in [this!!Save.hs]. [this!!Binder.hs] contains functions to bind template variables. The validators can be found in [this!!Validators.hs] using helper functions hosted by [this!!Utils.hs]. The algebraic datatype for companies can be found in [this!!Company.hs], a sample company in [this!!SampleCompany.hs]. Functionality to total and cut is provided by [this!!Total.hs] and [this!!Cut.hs]. [this!!Focus.hs] provides a focus datatype and functions on top of it. Various types used by the server can be found in [this!!Types.hs]. The [this!!static] folder contains the sytlesheet for the application and images, while [this!!templates] contains the (X)HTML templates.",
	"usage":"* [this!!Main.hs] can to be consulted with runhaskell to avoid the compilation step.\nThere is a [this!!Makefile] with a target ''run'' to do this.\n* Open ''http:\/\/localhost:8000\/Company\/View\/CompanyFocus'' to demo, starting with the root view.\n\n[[Category:Web application]]"
},
{
	"name":"haskell",
	"summary":"a simple implementation in [[Language:Haskell]]",
	"motivation":"Basic style of [[functional programming]] is applied. That is,\n[[algebraic datatype]]s are used to represent companies, and recursive,\n[[Pure computation|pure]] functions implement the [[query]] for\ntotaling salaries and the [[:Category:transformation]] for cutting\nsalaries. Since (sufficiently restrictive) algebraic datatypes are\namenable to uniform read and show functions, basic [[serialization]] is\nimmediately enabled.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Haskell 98"}],
	"technologies":[{"name":"GHCi"}],
	"architecture":"The implementation is straightforward. \n\nThere are Haskell modules for the basic features.\n\n* [[101feature:Company]]: ''Company.hs''\n* [[101feature:Total]]: ''Total.hs''\n* [[101feature:Cut]]: ''Cut.hs''\n\n[[101feature:Serialization]] is enabled by \"deriving\" clauses in ''Company.hs''.\nFinally, there is a ''Main'' module which collects a few test scenarios; see below.",
	"usage":"The Haskell module ''Main'' has to be consulted with GHCi, and the\n''main'' function has to be applied so that output for the test\nscenarios is produced. The ''expected'' output is available through\nthe file ''baseline''. There is a ''Makefile'' with a target ''test''\nfor [[test automation]]."
},
{
	"name":"haskellCGI",
	"summary":"[[Web programming|Web programming]] with [[Technology:CGI]] in [[Language:Haskell]]",
	"motivation":"We make use of the [[Technology:CGI]] library for Haskell to provide a C\/S  [[Web Application|web application]] for [[101feature:Company|companies]]. \nThat is, we exercise processing [[HTTP Request|requests]] from and returning [[HTTP Respond|responds]] to a web client using the CGI technology. We extract request parameters from the [[URL]]. That is, we make use of [[Technology:HTTP|HTTP]] GET parameters. The user can either request to view or [[101feature:Cut|cut]] a company\/department\/employee or to save an edited company\/department\/employee. By making use of the [[Zipper]] inspired focus concept (see the illustration section of the [[101implementation:wxHaskell|wxHaskell]] implementation for details) and by passing such a focus parameter in the URL we specify which part of the company should be displayed. Client-sided company data is stored in [[Cookie|cookies]]. We also demonstrate the use of a [[Language:XHTML]] combinator [[:Category:Library|library]] to compose new pages.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"distribution"}],
	"languages":[{"name":"Haskell"},
		{"name":"XHTML"},
		{"name":"CSS"}],
	"technologies":[{"name":"CGI"},
		{"name":"GHC"}],
	"illustration":"The server is set up as follows:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/Main.hs\" line>\nmain = runCGI $ handleErrors cgiMain\n<\/syntaxhighlight>\nWe use a default error handler provided by the CGI library ''Network.CGI''. <syntaxhighlight lang=\"haskell\" enclose=\"none\">cgiMain<\/syntaxhighlight> is the main request handler, which is shown in the next section.\nIn the following we will demonstrate how a specific request is processed by the server.\n\n=== Cutting an employee's salary ===\n\n'''Scenario:''' After receiving an employee view the user clicks the cut button in the browser. The browser sends a request to the server using this URL:\n\n''<nowiki>http:\/\/localhost\/cgi-bin\/HaskellCgi\/company.cgi?focus=EmployeeFocus%20[1,0,0]%200&<\/nowiki>''\n''<nowiki>action=Cut<\/nowiki>''\n\nBecause of the fact that the CGI library does not support any extraction of information out of the URL path (as opposed to the [[101implementation:happstack|happstack]] implementation), parameters are encoded as URL parameters:\n\n* The action (here <syntaxhighlight lang=\"haskell\" enclose=\"none\">Cut<\/syntaxhighlight>)\n* The focus (here <syntaxhighlight lang=\"haskell\" enclose=\"none\">EmployeeFocus [1,0,0]<\/syntaxhighlight>)\n\n==== Main request handler ====\n\nThe main request handler is defined as follows:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/Response.hs\" line>\ncgiMain :: CGI CGIResult\ncgiMain =  do\n    f <- getInput \"focus\"\n    let focusP = maybe CompanyFocus read f\n    a <- getInput \"action\"\n    let actionP = maybe View read a\n    chtml <- (doAction actionP) focusP\n    let title = \"101companies WebApp\" \n    output $ renderHtml $ page title $ chtml\n      where\n        doAction ap = case ap of\n          View  -> doView\n          Cut   -> doCut\n          Save  -> doSave \n<\/syntaxhighlight>\nWe are working inside the <syntaxhighlight lang=\"haskell\" enclose=\"none\">CGI<\/syntaxhighlight> monad, which is provided by the CGI library. In lines 3 and 5 <syntaxhighlight lang=\"haskell\" enclose=\"none\">getInput :: MonadCGI m => String -> m (Maybe String)<\/syntaxhighlight> tries to get the focus and action input parameters as <syntaxhighlight lang=\"haskell\" enclose=\"none\">String<\/syntaxhighlight> values, which we process in lines 4 and 6. If a parameter is set, that is, <syntaxhighlight lang=\"haskell\" enclose=\"none\">getInput<\/syntaxhighlight> returns <syntaxhighlight lang=\"haskell\" enclose=\"none\">Just a<\/syntaxhighlight>, we <syntaxhighlight lang=\"haskell\" enclose=\"none\">read<\/syntaxhighlight> the String to values of <syntaxhighlight lang=\"haskell\" enclose=\"none\">Focus<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">Action<\/syntaxhighlight>. If a parameters is not set, we use a default focus respectively a default action. \n\nWe call <syntaxhighlight lang=\"haskell\" enclose=\"none\">doAction<\/syntaxhighlight>, which is defined in lines 11-14. Based on the <syntaxhighlight lang=\"haskell\" enclose=\"none\">Action<\/syntaxhighlight> value <syntaxhighlight lang=\"haskell\" enclose=\"none\">doAction<\/syntaxhighlight> returns one of the action functions <syntaxhighlight lang=\"haskell\" enclose=\"none\">doView<\/syntaxhighlight>, <syntaxhighlight lang=\"haskell\" enclose=\"none\">doCut<\/syntaxhighlight> or <syntaxhighlight lang=\"haskell\" enclose=\"none\">doSave<\/syntaxhighlight>. In this scenario the <syntaxhighlight lang=\"haskell\" enclose=\"none\">case<\/syntaxhighlight> expression matches on <syntaxhighlight lang=\"haskell\" enclose=\"none\">Cut<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">doAction<\/syntaxhighlight> returns <syntaxhighlight lang=\"haskell\" enclose=\"none\">doCut<\/syntaxhighlight>. <syntaxhighlight lang=\"haskell\" enclose=\"none\">cgiMain<\/syntaxhighlight> applies the focus to the action function in line 7. The action function returns an <syntaxhighlight lang=\"haskell\" enclose=\"none\">Html<\/syntaxhighlight> value, which is used in line 9 as the content of a new page, rendered to an HTML document and returned as the <syntaxhighlight lang=\"haskell\" enclose=\"none\">CGIResult<\/syntaxhighlight>.\n\n==== Cutting the cookie ====\n\nThe function <syntaxhighlight lang=\"haskell\" enclose=\"none\">doCut<\/syntaxhighlight> performs the actual cut action on the company cookie:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/Cut.hs\">\ndoCut :: Focus -> CGI Html\ndoCut f = do\n    c <- tryReadCCookie\n    let cutC = readCutWrite f c   \n    writeCCookie cutC\n    return $ html f cutC\n<\/syntaxhighlight>\nThe company cookie is read using <syntaxhighlight lang=\"haskell\" enclose=\"none\">tryReadCCookie<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/Save.hs\" line>\ntryReadCCookie = liftM (fromMaybe company) $ \n                 readCookie \"companyCookie\"\n<\/syntaxhighlight>\nThis function tries to read the company cookie. If the client does not have this cookie stored, the default company is returned.\nIn line 4 <syntaxhighlight lang=\"haskell\" enclose=\"none\">doCut<\/syntaxhighlight> calls <syntaxhighlight lang=\"haskell\" enclose=\"none\">readCutWrite<\/syntaxhighlight>, which reads a company, department or employee based on the focus, cuts it and replaces it within the company (see [this!!Cut.hs] for details). In line 5 the manipulated company is written back into the cookie using <syntaxhighlight lang=\"haskell\" enclose=\"none\">writeCCookie<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/Save.hs\" line>\nwriteCCookie s = setCookie $ \n                 newCookie \"companyCookie\" $ \n                 show s    \n<\/syntaxhighlight>\n==== Returning HTML ====\n\nAfter the company data is saved in the cookie <syntaxhighlight lang=\"haskell\" enclose=\"none\">doCut<\/syntaxhighlight> calls <syntaxhighlight lang=\"haskell\" enclose=\"none\">html<\/syntaxhighlight> passing the focus and the new company:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellCGI\/CompanyHtml.hs\" line>\nhtml :: Focus -> Company -> Html\nhtml f = case f of \n  CompanyFocus        -> companyHtml f\n  (DeptFocus _)       -> deptHtml f\n  (EmployeeFocus _ _) -> employeeHtml f\n  (ManagerFocus _)    -> employeeHtml f   \n<\/syntaxhighlight>\nBased on the focus <syntaxhighlight lang=\"haskell\" enclose=\"none\">html<\/syntaxhighlight> calls one of the functions for composing HTML. In this scenario <syntaxhighlight lang=\"haskell\" enclose=\"none\">case<\/syntaxhighlight> matches on <syntaxhighlight lang=\"haskell\" enclose=\"none\">(EmployeeFocus _ _)<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">employeeHtml<\/syntaxhighlight> is called. This function composes HTML for the employee in question using various HTML combinators (see [this!!CompanyHtml.hs] for details).",
	"architecture":"In [this!!Main.hs] the server is set up using request handlers provided by [this!!Response.hs]. The save actions are performed by functionality hosted by [this!!Save.hs]. An algebraic datatype for actions is definied in [this!!Types.hs]. HTML pages are composed in [this!!CompanyHtml.hs].\nThe algebraic datatype for companies can be found in [this!!Company.hs]. [this!!Focus.hs] provides a focus datatype and functions on top of it. A sample company can be found in [this!!SampleCompany.hs]. [this!!Cut.hs] and [this!!Total.hs] provide cut and total functionality.",
	"usage":"* First you need a webserver. In the following we explain the steps for XAMPP<cite>xampp<\/cite>.\n* Compile [this!!Main.hs] to a CGI file using GHC: <syntaxhighlight lang=\"make\">ghc --make -o company.cgi Main.hs<\/syntaxhighlight>\n* Place ''company.cgi'' in the folder ''cgi-bin'' of your XAMPP installation.\n* Place [this!!style.css] in the folder ''htdocs'' of your XAMPP installation.\n* Open ''http:\/\/localhost\/cgi-bin\/haskellCGI\/company.cgi'' in a web browser to see the application's root view.\nCompiling the project is scripted by the ''run'' target in [this!!Makefile.hs]."
},
{
	"name":"haskellConcurrent",
	"summary":"concurrent programming in [[Language:Haskell]]",
	"motivation":"We make use of [[Language:Haskell]]'s [[101feature:Concurrency|concurrency]] support. That is, we divide computations into multiple threads and make use of synchronized variables ([[MVar]]), which are shared among different threads. \nEach thread [[101feature:Total|totals]] or [[101feature:Cut|cuts]] only the salaries in a specified department; subdepartments are handled by new threads.\nThe result of the computations (<syntaxhighlight lang=\"haskell\" enclose=\"none\">Float<\/syntaxhighlight> resp. <syntaxhighlight lang=\"haskell\" enclose=\"none\">Company<\/syntaxhighlight> values) are stored in an MVar and then collected and aggregated with other results by the \"upper\" thread.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"concurrency"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"GHCi"}],
	"illustration":"=== Concurrent cutting ===\n\nWe create new threads using <syntaxhighlight lang=\"haskell\" enclose=\"none\">forkIO :: IO () -> IO ThreadId<\/syntaxhighlight> provided by Haskell's concurrency library <syntaxhighlight lang=\"haskell\" enclose=\"none\">Control.Concurrent<\/syntaxhighlight>. This function executes the given IO action in a new thread and returns a <syntaxhighlight lang=\"haskell\" enclose=\"none\">ThreadId<\/syntaxhighlight> value. On the top company level we do so for every department:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellConcurrent\/Cut.hs\">\ncutCompany :: Company -> IO Company\ncutCompany (Company n depts) = do\n    mvars <- forM depts $ \\d -> do\n        mvar' <- newEmptyMVar\n        forkIO $ cutDept mvar' d\n        return mvar'\n    cutDepts <- takeAllMVars mvars\n    return $ Company n cutDepts\n<\/syntaxhighlight>\nWe iterate over the departments by making use of <syntaxhighlight lang=\"haskell\" enclose=\"none\">forM<\/syntaxhighlight> in line 3. For each department we create a new empty <syntaxhighlight lang=\"haskell\" enclose=\"none\">MVar<\/syntaxhighlight> value, which we then pass to the cut function, which we start in a new thread. We collect all <syntaxhighlight lang=\"haskell\" enclose=\"none\">MVar<\/syntaxhighlight> values in <syntaxhighlight lang=\"haskell\" enclose=\"none\">mvars<\/syntaxhighlight>. In line 7 we wait for the results of the computations. The new company is returned in line 8. Similar to this we cut departments:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellConcurrent\/Cut.hs\">\ncutDept :: MVar Department -> Department -> IO ()\ncutDept mvar (Department n m dus eus) = do\n    mvars <- forM dus $ \\d -> do\n        mvar' <- newEmptyMVar\n        forkIO $ cutDept mvar' d\n        return mvar'\n    cutDus <- takeAllMVars mvars\n    putMVar mvar $ Department n (cutEmployee m) \n                                (cutDus) \n                                (map cutEmployee eus)    \n<\/syntaxhighlight>\nThe difference to <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutCompany<\/syntaxhighlight> is that <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutDept<\/syntaxhighlight> puts the new department in a given <syntaxhighlight lang=\"haskell\" enclose=\"none\">MVar<\/syntaxhighlight> value.\n\nThe cutting of direct department employees is not performed in a new thread:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellConcurrent\/Cut.hs\">\ncutEmployee :: Employee -> Employee\ncutEmployee (Employee name address salary) = Employee name address $ salary \/ 2\n<\/syntaxhighlight>\n=== Collecting results ===\n\nBoth functions <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutCompany<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutDept<\/syntaxhighlight> need to wait for the child-threads to terminate. To do so we provide a function <syntaxhighlight lang=\"haskell\" enclose=\"none\">takeAllMVars<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellConcurrent\/Utils.hs\">\ntakeAllMVars ::  [MVar a] -> IO [a]\ntakeAllMVars = mapM takeMVar\n<\/syntaxhighlight> \nThis function takes all <syntaxhighlight lang=\"haskell\" enclose=\"none\">MVar<\/syntaxhighlight> values one by one blocking on every empty MVar.",
	"architecture":"[this!!Total.hs] and [this!!Cut.hs] provide functionality for totaling and cutting salaries in a concurrent way. \n[this!!Utils.hs] contains a function to collect content of a list of <syntaxhighlight lang=\"haskell\" enclose=\"none\">MVar<\/syntaxhighlight> values.\nThe algebraic datatype for companies can be found in [this!!Company.hs]. \n[this!!Main.hs] collects test scenarios for totaling and cutting a sample company hosted by [this!!SampleCompany.hs].",
	"usage":"* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]].",
	"issues":"* The current implementation does not address the problem of a possibly unbalanced department tree.\n* The collection function for MVars blocks on every empty element. We may need a more sophisticated collection function."
},
{
	"name":"haskellDB",
	"summary":"type-save [[:Category:Database_management_system|database]] programming with [[Technology:HaskellDB]]",
	"motivation":"We make use of [[Technology:HaskellDB|HaskellDB]] to express [[:Category:Database_management_system|database]] [[Query|queries]] as [[Language:Haskell]] functions rather than [[Language:SQL]]-statements (like in the [[101implementation:hdbc|hdbc]] implementation). That is, we use the rich combinator [[:Category:Library|library]] of HaskellDB to express [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] statements based on [[Relational algebra|relational algebra]]. We illustrate combinators for projection, selection, aggregation and renaming. Query results are [[101feature:Mapping|mapped]] to values of user-defined attributes in Haskell.\nWe connect to the underlining [[Technology:MySQL]] database through a HaskellDB-[[Technology:HDBC]]-[[Technology:ODBC]] back-end. We show the common approach of separating query\/statement definition from the actual [[:Category:Database management system|database implementation]]-dependent query\/statement execution <cite>bringert2004student<\/cite>. That is, the queries and statements themselves are database implementation-independent.\n\nThis implementation also demonstrates the use of [[Technology:DBDirect]]. We use this tool to generate modules describing the database. These modules are the basis for querying the relational data.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"mapping"}],
	"languages":[{"name":"Haskell"},
		{"name":"SQL"}],
	"technologies":[{"name":"HaskellDB"},
		{"name":"ODBC"},
		{"name":"HDBC"},
		{"name":"DBDirect"},
		{"name":"MySQL"},
		{"name":"GHCi"}],
	"illustration":"=== Connecting to the database ===\n\nWe provide a function to connect to a database and execute an action:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/MyConnection.hs\">\nexecute :: (Database -> IO a) -> IO a\nexecute = connect driver conf\n  where           \n    conf = [ (\"Driver\",\"MySQL ODBC 5.1 Driver\")\n           , (\"Port\",\"3306\")\n           , (\"Server\", \"localhost\")\n           , (\"User\", \"root\")\n           , (\"Database\", \"101companies\") ]\n<\/syntaxhighlight>\nWe use <syntaxhighlight lang=\"haskell\" enclose=\"none\">connect<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">driver<\/syntaxhighlight>, which are both provided by the HDBC-ODBC back-end.\nBy looking at the return type of the function one can see that any database function of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Database -> IO a<\/syntaxhighlight> can be applied to <syntaxhighlight lang=\"haskell\" enclose=\"none\">execute<\/syntaxhighlight> resulting in the specified IO action and possibly a result of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">a<\/syntaxhighlight>. By encapsulating the connection process like this we achieve complete independence from the underling database implementation for all queries and statements. \n\n=== DBDirect ===\n\nWe use the DBDirect command <syntaxhighlight lang=\"make\" enclose=\"none\">dbdirect-hdbc-odbc<\/syntaxhighlight> (see the usage section for the complete command). This command generates a module describing the database by naming tables and fields. Compiling this module with GHC creates one module per table, each module holding actual variables for tables and fields. These variables are the basis for the following totaling query.\n\n=== Totaling ===\n\nWe import the description modules for the companies and employees tables:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/Total.hs\">\nimport qualified DBDesc.Employee as E\nimport qualified DBDesc.Company as C\n<\/syntaxhighlight>\nWe define a special field for storing the sum of all salaries:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/Total.hs\">\ndata Ttl = Ttl\n\ninstance FieldTag Ttl where fieldName _ = \"ttl\"\n  \nttl :: Attr Ttl Double\nttl = mkAttr Ttl  \n<\/syntaxhighlight>\nWe declare <syntaxhighlight lang=\"haskell\" enclose=\"none\">Ttl<\/syntaxhighlight> to be an instance of the <syntaxhighlight lang=\"haskell\" enclose=\"none\">FieldTag<\/syntaxhighlight> class by specifying what the name of the field should be. We use this field and HaskellDB's <syntaxhighlight lang=\"haskell\" enclose=\"none\">mkAttr<\/syntaxhighlight> to define an attribute <syntaxhighlight lang=\"haskell\" enclose=\"none\">ttl<\/syntaxhighlight> for holding a <syntaxhighlight lang=\"haskell\" enclose=\"none\">Double<\/syntaxhighlight> value.\nThe actual total query is defined as follows:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/Total.hs\">\ntotal :: String -> Query (Rel (RecCons Ttl (Expr Double) RecNil))\ntotal cname = do \n  es <- table E.employee\n  cs <- table C.company\n\n  restrict $\n    ( fromNull (constant 0) (cs!C.xid) .==. es!E.cid \n      .&&. \n      cs!C.name .==. constant cname )\n\n  project (ttl << _sum (es!E.salary))\n<\/syntaxhighlight>\nWe are working in the <syntaxhighlight lang=\"haskell\" enclose=\"none\">Query<\/syntaxhighlight> monad. The <syntaxhighlight lang=\"haskell\" enclose=\"none\">table<\/syntaxhighlight> functions return all records in the given table. Using two tables gives us the relational cross product of those tables lines 3 and 4. We use HaskellDB's selection function <syntaxhighlight lang=\"haskell\" enclose=\"none\">restrict<\/syntaxhighlight> in line 6-9 to select only those rows in which the company-id of the employee is equal to the company which has the given name <syntaxhighlight lang=\"haskell\" enclose=\"none\">cname<\/syntaxhighlight>. By making use of <syntaxhighlight lang=\"haskell\" enclose=\"none\">project<\/syntaxhighlight> in line 11 we only select the salary column and then use the aggregation function <syntaxhighlight lang=\"haskell\" enclose=\"none\">_sum<\/syntaxhighlight> to total all salaries. After that we put the total value in <syntaxhighlight lang=\"haskell\" enclose=\"none\">ttl<\/syntaxhighlight>. \n\n=== Executing the query ===\n\nWe use <syntaxhighlight lang=\"haskell\" enclose=\"none\">query<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">execute<\/syntaxhighlight> to execute the totaling query:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/Main.hs\">\nlet cname = \"meganalysis\"\n[res] <- execute $ (flip $ query) $ total cname\n<\/syntaxhighlight>\nThis gives us a list (which we expect to be a singleton list) of records. We can now access the <syntaxhighlight lang=\"haskell\" enclose=\"none\">ttl<\/syntaxhighlight> attribute of the record <syntaxhighlight lang=\"haskell\" enclose=\"none\">res<\/syntaxhighlight> by using the <syntaxhighlight lang=\"haskell\" enclose=\"none\">(!)<\/syntaxhighlight>-operator and print the total value:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellDB\/Main.hs\">\nprint $ res!ttl\n<\/syntaxhighlight>",
	"architecture":"We provide MySQL-scripts to create (see [this!!Company.sql]) company tables and populate (see [this!!Meganalysis.sql]) these tables. [this!!Total.hs] and [this!!Cut.hs] provide totaling and cutting functionality using HaskellDB's relational algebra library. [this!!MyConnection.hs] encapsulates the process of connecting to the MySQL database. [this!!Main.hs] collects test scenarios for totaling and cutting.",
	"usage":"=== Setup ===\n\n* Follow the steps of setting up the database as described in the usage section for the [[101implementation:hdbc|hdbc]] implementation.\n\n=== Generating the database description ===\n\n* Execute the following command in the implementation folder: \n<syntaxhighlight lang=\"make\">\ndbdirect-hdbc-odbc \"DBDesc\" \"DBDesc\" \\\n                \"Driver=MySQL ODBC 5.1 Driver;\\\n\t\tPort=3306;\\\n\t\tServer=localhost;\\\n\t\tUser=root;\\\n\t\tDatabase=101companies\"\n<\/syntaxhighlight>\n* Compile the ''DBDesc'' module using GHC: <syntaxhighlight lang=\"make\" enclose=\"none\">ghc DBDesc<\/syntaxhighlight>\n\n=== Testing ===\n\n* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' covering both database descriptions generation and testing."
},
{
	"name":"haskellLogger",
	"summary":"[[101feature:Logging|Logging]] in [[Language:Haskell]] by means of the [[Writer Monad|Writer monad]]",
	"motivation":"We exercise [[101feature:Logging|logging]] in [[Language:Haskell]] by making use of the [[Writer Monad|Writer monad]]. That is, during the process of [[101feature:Total|totaling]] and [[101feature:Cut|cutting]] [[101feature:Company|companies]] we log messages regarding intermediate results. In this implementation we choose that logs should be of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">[String]<\/syntaxhighlight>, yet they could be of any [[Monoid|monoid]] type.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"logging"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"GHCi"}],
	"illustration":"=== Logging cutting ===\n\nWe provide functionality for cutting all company, department and employee salaries. In the following we will show how cutting all salaries in a given department is realized in the current implementation.\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellLogger\/Cut.hs\" line>\ncutLogDept :: Int -> Department -> Writer Log Department\ncutLogDept n d@(Department name m dus eus) = do\n    tell [replicate n '\\t' ++ \"Starting cutting \"\n                           ++ \"department \\\"\" \n                           ++ name \n                           ++ \"\\\", old Total = \" \n                           ++ (show $ totalDept d)]\n    cutManager <- cutLogEmployee (n + 1) m\n    cutDus <- mapM (cutLogDept (n + 1)) dus\n    cutEus <- mapM (cutLogEmployee (n + 1)) eus\n    let cutD = Department name cutManager cutDus cutEus\n    tell [replicate n '\\t' ++ \"Done cutting \" \n                           ++ \"department \\\"\" \n                           ++ name \n                           ++ \"\\\", new Total = \" \n                           ++ (show $ totalDept cutD)]\n    return cutD\n<\/syntaxhighlight>\nIn line 3 we log the start of the process of cutting a department by adding a message containing the department's name and the old total salary. We make use of the <syntaxhighlight lang=\"haskell\" enclose=\"none\">tell<\/syntaxhighlight> function, which is provided by the ''Control.Monad.Writer'' module, to add messages to the log.\nTo prettyPrint this log we indent all log lines using the given indent size <syntaxhighlight lang=\"haskell\" enclose=\"none\">n<\/syntaxhighlight>. In line 8 we cut the department manager's salary by passing the manager and an increased indent size to <syntaxhighlight lang=\"haskell\" enclose=\"none\">cutLogEmployee<\/syntaxhighlight>. To cut all sub departments and employees we make use of the monadic map function <syntaxhighlight lang=\"haskell\" enclose=\"none\">mapM<\/syntaxhighlight> in lines 9 and 10. In the following lines we log that department cutting is finished and what the new total salary is. In line 17 we return the cut <syntaxhighlight lang=\"haskell\" enclose=\"none\">Department<\/syntaxhighlight> value.",
	"architecture":"[this!!Total.hs] and [this!!Cut.hs] contain functionality to total and cut salaries while logging the process of doing so. [this!!Types.hs] holds the log type and a function for prettyprinting logs. The algebraic datatype for companies can be found in [this!!Company.hs]. [this!!Main.hs] collects test scenarios for totaling and cutting a sample company provided by [this!!SampleCompany.hs].",
	"usage":"* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"haskellParser",
	"summary":"parsing textual syntax with [[Technology:Parsec]] in [[Language:Haskell]]",
	"motivation":"We make use of [[Language:Haskell]]'s [[Technology:Parsec]] [[Parsing|parser]] combinator [[:Category:Library|library]] to parse concrete textual syntax for [[101feature:Company|companies]].\nWe combine smaller parsers, say for salaries, to larger parsers, say for departments and employees, to build a parser for companies.\nIn terms of parsing we exercise sequence, alternative and option.\nThis implementation also demonstrates [[Functor|applicative functors]] and functor combinators provided by the ''Control.Applicative'' module.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"mentoring"},
		{"name":"serialization"},
		{"name":"parsing"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"GHCi"},
		{"name":"Parsec"}],
	"illustration":"=== Parser type ===\n\nWe define a type alias of all parsers that are defined in this implementation:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Parser.hs\" line>\ntype P = Parsec String ()\n<\/syntaxhighlight>\nThat is, we are dealing with parsers of stream type <syntaxhighlight lang=\"haskell\" enclose=\"none\">String<\/syntaxhighlight> and state type <syntaxhighlight lang=\"haskell\" enclose=\"none\">()<\/syntaxhighlight> (no state). The return type of running such a parser is explained further below.\n\n=== Primitive parsers ===\n\nIn order to build the company parser we first need some primitive parsers.\nFor parsing a given <syntaxhighlight lang=\"haskell\" enclose=\"none\">String<\/syntaxhighlight> value we define:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Parser.hs\" line>\npString :: String -> P String\npString s = string s <* spaces\n<\/syntaxhighlight>\nThis parser also consumes trailing spaces.\nWe also need a parser for literals. <syntaxhighlight lang=\"haskell\" enclose=\"none\">pLit<\/syntaxhighlight> parses a quoted string:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Parser.hs\" line>\npLit :: P String\npLit = string \"\\\"\" *> many (noneOf \"\\\"\") <* string \"\\\"\" <* spaces\n<\/syntaxhighlight>\n=== Parsing a department ===\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Parser.hs\" line>\npDepartment :: P Department\npDepartment = Department\n  <$  pString \"department\" <*> pLit \n  <*  pString \"{\" <*> pEmployee \"manager\"\n  <*> many pSubUnit <* pString \"}\"\n<\/syntaxhighlight>\nWe make use of the <syntaxhighlight lang=\"haskell\" enclose=\"none\">(<$) :: Functor f => a -> f b -> f a <\/syntaxhighlight> operator in line 3. That is, we pass the department constructor <syntaxhighlight lang=\"haskell\" enclose=\"none\">Department<\/syntaxhighlight> and a parser for all constructor parameters (for name, manager and for the list of subunits) to receive a parser for departments. \nIn line 3 we parse the keyword for department declaration \"department\". In the next line we parse the department name, followed by an opening curly bracket. We compose a parser for the department's manager using the employee parser <syntaxhighlight lang=\"haskell\" enclose=\"none\">pEmployee<\/syntaxhighlight>, which should use \"manager\" as the keyword. In the last line <syntaxhighlight lang=\"haskell\" enclose=\"none\">many :: f a -> f [a]<\/syntaxhighlight> is used to parse the list of subunits using <syntaxhighlight lang=\"haskell\" enclose=\"none\">pSubUnit<\/syntaxhighlight> as the parser for each subunits. Finally, we define that we expect a closing curly bracket at the end of a department declaration.\n\n=== Running the Parser ===\n\nRunning the company parser is realized by making use of <syntaxhighlight lang=\"haskell\" enclose=\"none\">runP<\/syntaxhighlight>:\n<syntaxhighlight lang=\"haskell\">\nrunP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a\n<\/syntaxhighlight>\nWe illustrated above that we use parsers of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Parsec String ()<\/syntaxhighlight>, which on the top level parse values of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Company<\/syntaxhighlight>. Therefore we can simplify the type signature: \n<syntaxhighlight lang=\"haskell\">\nParsec String () Company -> () -> SourceName -> String -> Either ParseError a\n<\/syntaxhighlight>\nWhen we choose <syntaxhighlight lang=\"haskell\" enclose=\"none\">\"input\"<\/syntaxhighlight> as the source name we can define a function to run the company parser:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Parser.hs\" line>\nparseCompany :: String -> Either ParseError Company\nparseCompany = runP (spaces *> pCompany <* eof) () \n               \"input\"\n<\/syntaxhighlight>\nWe added a parser for possible leading spaces and a parser for the EOF-symbol.\n\n=== Executing the Parser ===\n\nIn [this!!Main.hs] we execute the company parser:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Main.hs\" line>\nparsedCompany <- liftM parseCompany $ \n                 readFile \"sample.Company\"\n<\/syntaxhighlight>\nThe variable <syntaxhighlight lang=\"haskell\" enclose=\"none\">parsedCompany<\/syntaxhighlight> either holds a <syntaxhighlight lang=\"haskell\" enclose=\"none\">ParseError<\/syntaxhighlight> value or a parsed company. \nWe define a function for printing, which handles both cases:\n\n<syntaxhighlight lang=\"haskell\" source=\"haskellParser\/Main.hs\" line>\neitherPrint :: Show a => Either ParseError Company -> (Company -> a) -> IO ()\neitherPrint (Right c) f = print $ f c\neitherPrint (Left e) _ = print e\n<\/syntaxhighlight>\nIn case parsing was successful this function applies a given function to the company and prints the result. In case of a parse error, it prints the error message.\nWe can use this function to print the total salary of <syntaxhighlight lang=\"haskell\" enclose=\"none\">parsedCompany<\/syntaxhighlight> in case of parsing success:\n\n<syntaxhighlight lang=\"haskell\" line>\neitherPrint parsedCompany total\n<\/syntaxhighlight>",
	"architecture":"[this!!Parser.hs] provides the Parsec-based parser. [this!!Company.hs] holds the algebraic datatype for companies, \nwhile [this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut companies. [this!!SampleCompany.hs] holds a sample company used to be compared to a parsed sample company (hosted by [this!!sample.Company]). [this!!Main.hs] collects test scenarios.",
	"usage":"* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"hdbc",
	"summary":"[[:Category:Database_management_system|Database]] programming with [[Technology:HDBC]]",
	"motivation":"We use [[Technology:HDBC]] to query [[101feature:Persistence|persisted]] company data. That is, we use embedded [[Language:SQL]] in [[Language:Haskell]] to [[101feature:Total|total]] \nand [[101feature:Cut|cut]] [[101feature:Company|company]] salaries within a [[:Category:Database_management_system|database]]. SQL query results are [[101feature:Mapping|mapped]] to special HDBC datatypes. In this context we demonstrate the use of [[Prepared statement|prepared statements]] in HDBC. We illustrate lazy fetching of query results. To connect to the [[Technology:MySQL]] database we use an [[Technology:ODBC|ODBC]] back-end. The actual functionality to cut and total salaries is independent from the concrete [[:Category:Database_management_system|database implementation]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"mapping"}],
	"languages":[{"name":"Haskell"},
		{"name":"SQL"}],
	"technologies":[{"name":"HDBC"},
		{"name":"MySQL"},
		{"name":"GHCi"},
		{"name":"ODBC"}],
	"illustration":"=== Connecting ===\n\nIn [this!!Main.hs] we connect to the MySQL database by using an ODBC driver and appropriate connection information:\n\n<syntaxhighlight lang=\"haskell\" source=\"hdbc\/Main.hs\">\nlet connString = \"Driver={MySQL ODBC 5.1 Driver};\"\n              ++ \"Server=localhost;\"\n              ++ \"Port=3306;\"\n              ++ \"Database=101companies;\"\n              ++ \"User=root;\"\nconn <- connectODBC connString\n<\/syntaxhighlight>\n=== Totaling ===\n\nThe function <syntaxhighlight lang=\"haskell\" enclose=\"none\">total<\/syntaxhighlight> defines a statement to total all salaries:\n\n<syntaxhighlight lang=\"haskell\" source=\"hdbc\/Total.hs\">\ntotal :: IConnection conn => conn -> String -> IO Double\ntotal conn cName = do\n     stmt <- prepare conn $ \n        \"SELECT salary \" ++ \n        \"FROM employee, company \" ++ \n        \"WHERE company.name = ? and \" ++ \n        \"company.id = employee.cid\"\n     execute stmt [toSql cName]\n     res <- fetchAllRows stmt\n     return $ sum (map (fromSql.head) res)        \n<\/syntaxhighlight>\nIn lines 3-7 we use a prepared statement in which the company name placeholder is then replaced by the given name <syntaxhighlight lang=\"haskell\" enclose=\"none\">cName<\/syntaxhighlight>. The statement is executed and we use the lazy HDBC function <syntaxhighlight lang=\"haskell\" enclose=\"none\">fetchAllRows<\/syntaxhighlight> in line 9 to get all salaries, which we then sum up lazy to a <syntaxhighlight lang=\"haskell\" enclose=\"none\">Double<\/syntaxhighlight> value and return in line 10. That is, salaries are fetched one by one from the database.\nWe can now use the open connection to total all salaries:\n<syntaxhighlight lang=\"haskell\" source=\"hdbc\/Main.hs\">\nlet cName = \"meganalysis\" \noldTotal <- total conn cName\n<\/syntaxhighlight>\nFunctionality to cut all salaries uses an UPDATE statement instead of SELECT (see [this!!Cut.hs] for details).",
	"architecture":"[this!!Company.sql] and [this!!Meganalysis.sql] provide SQL-scripts to create and populate company tables. [this!!Total.hs] and [this!!Cut.hs] provide totaling and cutting functionality using SQL statements. [this!!Main.hs] collects test scenarios for totaling and cutting.",
	"usage":"=== Setup ===\n\nWe need a local database server.\nIn the following we explain the steps for XAMPP <cite>xampp<\/cite>.\nWe also need an SQL tool to create and populate tables.\nIn the following we explain the steps for the MySQL Workbench <cite>mysqlworkbench<\/cite>.\n\n* Download and install XAMPP.\n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"Mysql\".\n* A local MySQL Server is now running:\n** '''Server Host''': localhost\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n** '''Port''': 3306\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n** '''Username''': root\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n** '''Password''': (empty password) \n* Connect to the database in MySQL Workbench.\n* Select the \"101companies\" schema or create it.\n* Create company tables: Run the SQL script [this!!Company.sql].\n* Populate company tables: Run the SQL script [this!!Meganalysis.sql].\n\n=== Testing ===\n\n* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"hibernate",
	"summary":"[[O\/R mapping]] with [[Technology:Hibernate]]",
	"motivation":"[[O\/R mapping]] or [[persistence]] on the Java platform is exercised using \n[[Technology:Hibernate]]. The primary data model for companies is a straightforward\nobject model for [[POJO]]s. A mapping is defined to associate a relational schema\nwith the classes. The mapping is specified in an [[Language:XML]] language and organized\nin a per-class manner. For each class, properties and [[:Category:relationship]]s are specified by\nthe mapping. It is insightful to compare the object model and the mapping-implied relational\nschema. It is also insightful to compare the latter schema with one that was ''natively'' \ndesigned from a relational database point of view; see [[101implementation:mySql]]. In \nparticular, the object model and the implied relational schema are essentially \"optimized\" \nfor downwards traversal of the company structure whereas a native relational schema would\nrather provide foreign keys for upwards navigation (such as navigating from an employee to\nits department or company).",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"mentoring"},
		{"name":"persistence"}],
	"languages":[{"name":"Java"},
		{"name":"SQL"},
		{"name":"HSQLDialect"},
		{"name":"HQL"},
		{"name":"XML"}],
	"technologies":[{"name":"Hibernate"},
		{"name":"HSQLDB"}],
	"illustration":"Consider the following sketch of the class for departments:\n\n<syntaxhighlight lang=\"java\">\npublic class Department {\n  private Long id;\n  private String name;\n  private Set<Employee> employees;\n  private Set<Department> subdepts;\n\n  public Long getId() { ... }\n  private void setId(Long id) { ... }\n  public String getName() { ... }\n  public void setName(String name) { ... }\n  public Set<Employee> getEmployees() { ... }\n  private void setEmployees(Set<Employee> employees) { ... }\n  public Set<Department> getSubdepts() { ... }\n  private void setSubdepts(Set<Department> subdepts) { ... }\n}\n<\/syntaxhighlight>\nEach persistent class must provide a property (i.e., a getter and a setter) for\nan ''id'' that can serve as primary key in the database. Properties of \ncollection types (in fact, set types) proxy for one-to-many relationships.\nOther than that, a persistent class is not much different from a regular\n[[POJO]]-like class. (There are some private setters that would be missing\nfrom a native object model. These setters are needed for object population.)\n\nConsider the mapping file of class ''Department'' to table ''DEPARTMENT'':\n\n<syntaxhighlight lang=\"xml\">\n<hibernate-mapping>\n <class name=\"org.softlang.company.Department\" table=\"DEPARTMENT\">\n  <id name=\"id\" column=\"ID\">\n    <generator class=\"native\" \/>\n  <\/id>\n  <property name=\"name\" \/>\n  <set name=\"employees\" cascade=\"all\">\n   <key column=\"DEPT_ID\" \/>\n   <one-to-many class=\"org.softlang.company.Employee\" \/>\n  <\/set>\n  <set name=\"subdepts\" cascade=\"all\">\n   <key column=\"DEPT_ID\" \/>\n   <one-to-many class=\"org.softlang.company.Department\" \/>\n  <\/set>\n <\/class>\n<\/hibernate-mapping>\n<\/syntaxhighlight>\nAll properties of the class are associated with the table.\nThat is, the ''id'' property is directly mapped to a primary key column\n''ID'' of the ''DEPARTMENT'' table. Also, the ''name'' property is mapped\nto a column of just that name---applying default mapping rules between\nSQL types and Java types. Further, the ''employees'' property is \nnon-trivially associated with a foreign key ''DEPT_ID'' of the \n''EMPLOYEE'' table---which is only indirectly identified through the \nmentioning of the ''Employee'' class; likewise for sub-departments.\n\nPersistent objects are brought back to life as follows:\n\n<syntaxhighlight lang=\"java\">\npublic Company loadCompany(String name) {\n  this.session = getSessionFactory().getCurrentSession();\n  this.session.beginTransaction();\n  List<?> result = this.session.createQuery(\n    \"from Company where name = '\" + name + \"'\").list();\n  for (Object o : result)\n    return (Company)o;\n  return null;\n}\n<\/syntaxhighlight>\nThat is, an [[Language:HQL]] query is executed to retrieve a company \nthat is identified by name; the Hibernate framework takes care of populating\nthe company object and all its sub-objects. If the requested company cannot be found,\nthen ''null'' is returned.\n\nFinally, consider the Hibernate configuration:\n\n<syntaxhighlight lang=\"xml\">\n<hibernate-configuration>\n <session-factory>\n  <!-- Database connection settings. -->\n  <property name=\"connection.driver_class\">org.hsqldb....\n  <property name=\"connection.url\">...\n  <property name=\"connection.username\">...\n  <property name=\"connection.password\">...\n   <!-- Create the database schema, if needed; update otherwise -->\n  <property name=\"hbm2ddl.auto\">update<\/property>\t\t\t  \t\t\t  \n  <!-- This part lists all the mapping files present in the project -->\n  <mapping resource=\"org\/softlang\/company\/Company.hbm.xml\" \/>\n  <mapping resource=\"org\/softlang\/company\/Department.hbm.xml\" \/>\n  <mapping resource=\"org\/softlang\/company\/Employee.hbm.xml\" \/>\n  ...\n <\/session-factory>\n<\/hibernate-configuration>\n<\/syntaxhighlight>\nThis configuration helps the runtime to connect to the right database, to find\nall mapping files of interest, and to define some essential settings. For instance,\nHibernate is informed here that the database catalog is to be updated automatically\n(see ''hbm2ddl.auto'' ... ''update'') upon starting a Hibernate session. In particular,\nif the mapping-implied tables are not yet declared in the database, then they will\nbe created automatically.",
	"architecture":"Package ''org.softlang.company'' hosts the java object model for [[101feature:Company]]\nand the O\/R-mapping files. Package ''org.softlang.features'' provides functionality for \n[[101feature:Total]] and [[101feature:Cut]] as well as boilerplate code for \n[[101feature:Persistence]]. The folder ''scripts'' contains SQL-scripts to create tables\n(extracted from the hibernate log; there is no need to execute these statements), and to \npopulate the tables (needed in the workflow described below). The Hibernate configuration \nfile is located in the root dir. The HSQLDB database files are located in the data dir.",
	"usage":"Please follow these steps carefully.\n\n=== Start from a clean setup ===\n\nUpon checking out the implementation, you are clean.\n\nThe \"make clean\" target in the root dir should bring you back to a clean setup.\n\nHowever, make sure the HSQL database server is shutdown as you go clean.\n\n=== Build the project ===\n\nThis is an Eclipse project.\n\nEverything is included.\n\nThe project should built fine within Eclipse without additional efforts.\n\n=== Start the HSQL database server ===\n\n* Go to the data dir of the distribution.\n* Run the following command in the command line:\n** > java -classpath ..\/lib\/hsqldb.jar org.hsqldb.Server \n** You can also send it to the background if you like.\n** You can also go to the root dir and run \"make start-db\" instead.\n\n=== Start the database monitor ===\n\n* Go to the root dir of the distribution.\n* Run the following command in the command line:\n** > java -classpath lib\/hsqldb.jar org.hsqldb.util.DatabaseManagerSwing\n** You can also send it to the background if you like.\n** You can also go to the root dir and run \"make start-gui\" instead.\n* When the GUI pops up, make sure to select '''\"HSQL Database Engine Server\"'''.\n\n=== Create tables ===\n\nThe tables are automatically created by trying to query them.\n\nThere is JUnit test ''Load'' in package ''org.softlang.tests'' which just does that.\n\nDo ''refresh'' in the database monitor to see all tables in the left panel.\n\n=== Populate tables ===\n\nSuitable INSERT statements for population are to be found in scripts\/PopulateTables.sql\n\nOpen the file and copy and paste its content over to the database monitor, and execute the statements.\n\nYou may want to double-check that the tables were populated.\n\nTo this end, enter a SQL statement such as \"select * from EMPLOYEE;\".\n\n=== More testing ===\n\nRun the JUnit test ''Operations'' in package ''org.softlang.tests''.\n\nThe modified state is '''not''' committed; hence, the test can be executed time and again.\n\nRun the JUnit test ''Constraints'' in package ''org.softlang.tests''.\n\nThere is no state changes.\n\nRun the JUnit test ''Save'' in package ''org.softlang.tests''.\n\nThe modified state is committed; the test will only succeed once.\n\n=== Finish off ===\n\nGo to the database monitor and enter and execute \"shutdown;\".\n\nQuit the database monitor.\n\nYou may also want to run \"make clean\" in the root dir to be clean for next time.",
	"issues":"* Efficiency\/incrementality of loading objects and saving changes"
},
{
	"name":"hibernate2",
	"summary":"[[O\/R mapping]] with [[Technology:Hibernate]]",
	"motivation":"An [[object model]] for companies is provided, as well as classes to total and cut salaries.\nThis is, we apply a basic style of [[OO programming]]. Instances the company model are [[Persistence|persisted]] by making use of the [[Technology:Hibernate]]\ntechnology. To that end the [[O\/R mapping]] is realized by making use of [[Language:XML]]-mapping files for departments, employees, subunits and persons.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"}],
	"languages":[{"name":"XML"},
		{"name":"Java"},
		{"name":"SQL"}],
	"technologies":[{"name":"Hibernate"},
		{"name":"HSQLDB"}],
	"architecture":"Package ''org.softlang.om'' holds the java object model for [[101feature:Company]] and the xml-mapping files.\n''org.softlang.hibernate'' provides functionality to [[101feature:Total]] and [[101feature:Cut]] salaries. \nThis package also hosts ''Init.java'' which tells hibernate to create tables; also test cases (see below) and\nand ''HibernateConnectivity.java'' to easily load and save company objects. This class uses the ''SessionFactory'' provided by ''HibernateUtil.java'' in ''org.softlang.util''.\nThe folder ''scripts'' contains sql-scripts to create tables (extracted from the hibernate log), populate data and to drop tables.\nHibernate configuration files (see below) can be found in the project's root folder.",
	"usage":"'''Steps of a typical demo:'''\n* Make sure you start from an initial distribution.\n* Build the project with Eclipse.\n(The following steps are explained in detail below.)\n* Start the HSQL database server.\n* Run ''org\/softlang\/hibernate\/Init.java'' to create tables.\n* Run the database monitor and populate the tables with scripts\/PopulateTables.\n* Patch hibernate.cfg.xml to disable \"drop and re-recreate\".\n* Run ''org\/softlang\/hibernate\/Tests.java''.\n\n\n'''How to start the database server:'''\n* Start it from the command line.\n* Go to the data dir of the distribution.\n* Run the following command:\n** > java -classpath ..\/..\/hibernate\/lib\/hsqldb.jar org.hsqldb.Server\n** You can also send it to the background if you like.\nYou can also go to the root dir and run a \"make start-db\".\n\n\n'''How to create new tables:'''\n* Run ''Init.java'' in ''org.softlang.hibernate''.\n\n\n'''How and why to start the database monitor:'''\n\n* Start it from the command line.\n* Run the following command:\n** > java -classpath ..\/hibernate\/lib\/hsqldb.jar org.hsqldb.util.DatabaseManagerSwing\n** You can also send it to the background if you like.\nYou can also go to the root dir and run a \"make start-gui\".\n* When the GUI pops up, make sure to select \"HSQL Database Engine Server\".\n* If you had performed Main already, you see the tables of the app.\n* Populate these tables:\n** Open scripts\/PopulateTables (File -> Open Script)\n** Press \"Execute SQL\"\n\n\n'''How and why to patch ''hibernate.cfg.xml?'' '''\n\nYou can edit that XML file in Eclipse.\nIt is the configuration that is used for Hibernate for persistency.\nUpon the first use the EventManager the database must be initialized.\nHence it says:\n: <property name=\"hbm2ddl.auto\">create<\/property>\nSubsequently, we want to keep all data.\nHence the line should be commented out.\n\n'''How to test:'''\n\n* Run ''Tests.java'' in ''org.softlang.hibernate''.",
	"issues":"* How to deal with acknowledgements? (See COPYRIGHT in svn)"
},
{
	"name":"html5XMLHttpRequest",
	"summary":"[[web programming]] with [[Language:HTML5]]",
	"motivation":"While the most [[Language:HTML5|HTML5]] implementations provide [[client-side]] data storage, this [[Category:101implementation|implementation]] attends to [[server-side]] data storage. The ''company.xml''-file with the company-data is loaded [[asynchronous communication|asynchronously]] by the client over [[Technology:XMLHttpRequest|HTTP-Request]]. The received data can be accessed via [[Technology:DOM]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"interaction"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"},
		{"name":"php"},
		{"name":"XML"}],
	"technologies":[{"name":"DOM"},
		{"name":"XMLHttpRequest"},
		{"name":"Webbrowser"}],
	"illustration":"The [[Technology:DOM]]-based [[101feature:Total]]-implementation in [[Language:JavaScript]] is:\n\n<syntaxhighlight lang=\"javascript\">\nfunction total(company) {\n\tvar t = 0;\n\tvar salaryNodes = company.getElementsByTagName(\"Salary\");\n\tfor (var i = 0; i < salaryNodes.length; i++) {\n\t\tvar element = salaryNodes[i];\n\t\tt += parseFloat(element.childNodes[0].nodeValue);\n\t}\n\treturn t;\n}\n<\/syntaxhighlight>\nThe implementation can access specific nodes of the xml document through [[Technology:DOM]] (''getElementsByTagName(\"...\")''). The result is a list of nodes (''salaryNodes''), which consist of all salaries in the [[101feature:Company|company]]. The sum of the ''nodeValue'' is the result for the [[101feature:Total]]-method.",
	"architecture":"The architecture is mostly identical to [[101implementation:html5local]]. The main difference is, that there is a need for a [[server-side]] application (for example in [[Language:php]]). This [[server-side]] application receives the data to be stored as a stream and save it in the ''company.xml''-file.",
	"usage":"* check out all files in the repository\n* Open the index.html with your web-browser (check [[Language:HTML5|HTML5]] for the HTML5-support of your browser)\n* This HTML5-program does not work over file-protocol when using Chrome. In this case, you need access over http. To gain access over http, you can use XAMPP, for example, to create a webserver. \n\n# Download XAMPP from http:\/\/www.apachefriends.org\/en\/xampp.html\n# Install XAMPP\n# Deploy ALL files (except README) to your htdocs-directory (for example: E:\\xampp\\htdocs\\101implementation-html5\\)\n# Start the XAMPP-Control Panel and activate Apache\n# Start your web-browser\n# Call http:\/\/localhost\/101implementation-html5\/index.html\n\n[[Category:Web application]]"
},
{
	"name":"html5ajax",
	"summary":"[[web programming]] with [[Language:HTML5]], [[Language:JavaScript]], [[Language:php]] and [[Language:SQL]]",
	"motivation":"* This [[Language:HTML5|HTML5]]-project provides an optimized [[server-side]] data storage. While other projects like [[101implementation:html5XMLHttpRequest|html5XMLHttpRequest]] transmit the whole company-data from the [[server]] to the [[client]], this application only transmit the necessary data for the current page, which is the essential principe of an [[Technology:Ajax]]-application.\n\n* The data-transfer is realized with [[Technology:XMLHttpRequest]] and a [[server-side]] [[Language:php]]-script. The client sends a request to the [[server]] and the [[Language:php]]-script decides, which data should be transmitted. The response is wrapped in a stringified [[Technology:JSON]]-Object, which easily can be decoded by the [[client]]. It is evident to use [[Language:SQL]] for data storage in combination with the [[server-side]] [[Language:php]]-script.\n\n* The use of [[Technology:JSON]] instead of [[Language:XML]] has a major advantage: The request and response messages are created in an [[OO_programming_paradigm|object-oriented]] style. These objects can easily be translated into [[Technology:JSON]]-strings. There is no additional effort for creating and interpreting complex [[Language:XML]]-messages.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"interaction"},
		{"name":"precedence"},
		{"name":"validation"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"},
		{"name":"php"},
		{"name":"SQL"}],
	"technologies":[{"name":"MySQL"},
		{"name":"XAMPP"},
		{"name":"JSON"},
		{"name":"Apache_HTTP_Server"},
		{"name":"XMLHttpRequest"},
		{"name":"Webbrowser"}],
	"illustration":"The client sends [[Technology:JSON]]-messages to the server using [[Technology:XMLHttpRequest]]. A [[Technology:JSON]]-message contains the information for the current page and some extra information about the action invoked on this page. A stringified JSON-object for cutting the company is looking like:\n\n<syntaxhighlight lang=\"text\">\n{\n\t\"id\":1,\n\t\"table\":\"company\",\n\t\"action\":\"cut\"\n}\n<\/syntaxhighlight>\nThis message tells the server to [[101feature:Cut|cut]] the company with the identifier 1. The answer for this request is a stringified company object with all needed informations about the [[101feature:Company|company]] (and nothing more):\n\n<syntaxhighlight lang=\"text\">\n{\n\t\"name\":\"meganalysis\",\n\t\"departments\":[\"Research\",\"Development\"],\n\t\"total\":199873.5\n}\n<\/syntaxhighlight>\nThe [[server]] receives the [[101feature:Cut|cut]]-request and performs the action:\n\n<syntaxhighlight lang=\"php\">\n\/\/ ---------------------------------------- cut company\nfunction cut($jsonObject) {\n\t$id = $jsonObject->id;\n\t$request = \"UPDATE employee SET salary = salary \/ 2 WHERE cid = $id\";\n\tmysql_query($request);\n        \n\treturn loadCompany($jsonObject);\n}\n<\/syntaxhighlight>",
	"architecture":"* This application is implemented with [[Architecture:MVC|MVC]]. The client is devided into the [[101feature:Interaction|view]] (e.g. [this!!\/client\/company.html company.html], [this!!\/client\/javascript\/view\/companyView.js companyView.js]), the controller ([this!!\/client\/javascript\/controller.js controller.js]) and the model (e.g. [this!!\/client\/javascript\/model\/companyModel.js companyModel.js]). The controller manages the requests triggered by the view and changes the view, when the data has changed. The model manages the data. This means, in that case, that the model performs the [[Technology:XMLHttpRequest|requests]] and receives the responses of the [[Language:php]]-server.\n\n* The [[Technology:XMLHttpRequest|requests]] are encoded with [[Technology:JSON]]. Visit http:\/\/en.wikipedia.org\/wiki\/JSON to get more information. The structure of the messages is described in the [[101implementation:html5ajax#Illustration|illustration]]-section.\n\n* There is a single [[server-side]] [[Language:php]]-script for each page (e.g. [this!!\/server\/companyServer.php companyServer.php]). Each script receives the [[Technology:JSON]]-message and performs the delivered action. Each action is implemented as a seperate function. The implementation of the responses is [[OO_programming_paradigm|object-oriented]], which guarantees a consistent form for the messages (e.g. [this!!\/server\/classes\/company.php company.php]).\n\n* The concrete data is stored in an [[Language:sql]]-database (comparing [[101implementation:mySql]]).\n\n* The [[client-side]] [[101feature:Validation]] is performed directly. If an exception occurs on the server, the response contains an error-flag and a list of field-identifiers and dedicated messages. This messages are delegated to the concerning fields in the GUI.",
	"usage":"You need a web- and sql-server to use this application. In this tutorial both will be taken by XAMPP: http:\/\/www.apachefriends.org\/en\/xampp.html\n\nThis tutorial adopts some parts of [[101implementation:mySql]]. The company.sql and sampleCompany.sql are modified for this project. They are located in the \"sqlScripts\" folder.\n\n* Download and install XAMPP\n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"MySQL\"\n* Use the guideline of [[101implementation:mySql]] up to \"Populate tables...\" with the modified sql-scripts.\n\nAfter the database is running, follow the next steps:\n\n* To start the application, you need to download all project-files except the README\n* Put the files into the htdocs-directory of your XAMPP (a new sub-directory in \"htdocs\" is recommended)\n* Run index.html\n\nThe project is provided as a netbeans-project. If you want to change the code, you have to:\n\n* Download (http:\/\/netbeans.org\/) and install [[Technology:NetBeans]]\n* \"Open project\" and select the html5ajax-folder\n\n[[Category:Web application]]"
},
{
	"name":"html5indexedDatabase",
	"summary":"[[web programming]] with [[Language:HTML5]]",
	"motivation":"The indexed database is the current alternative to the [[101implementation:html5sqlDatabase|web database]] (outdated!) in HTML5. Apart from web storage ([[101implementation:html5local|local storage]] and [[101implementation:html5session|session storage]]), the indexed database feature gains the main support in relation to [[offline storage]]. The access to the data is handled over [[asynchronous communication]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"interaction"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"}],
	"technologies":[{"name":"B-Tree"},
		{"name":"Webbrowser"}],
	"illustration":"This is the [[asynchronous communication|asynchronous]] version of the [[101feature:Cut]]-function. The communication between database and application is handled with transactions. After creating a transaction, the result is delivered by a cursor, which runs through the [[Technology:B-Tree|B-Tree]] and collects the wanted elements.\n\n<syntaxhighlight lang=\"javascript\">\ncompanies.indexedDB.cut = function() {\n\t\/\/ get database\n\tvar db = companies.indexedDB.db;\n\n\t\/\/ create transaction to the indexed database\n\tvar transEmp = db.transaction([\"Employee\"], IDBTransaction.READ_WRITE, 0);\n\t\/\/ retrieve employee store\n\tvar empStore = transEmp.objectStore(\"Employee\");\n\t\n\t\/\/ Get every single employee in the store\n\tvar keyRange = IDBKeyRange.lowerBound(0);\n\tvar cursorRequest = empStore.openCursor(keyRange);\n\n\t\/\/ cursor runs through the result-set\n\tcursorRequest.onsuccess = function(e) {\n\t\tvar result = e.target.result;\n\t\tif(!!result == false)\n\t\t\treturn;\n\n\t\t\/\/ cut the salary\n\t\tresult.value.salary = result.value.salary \/ 2;\n\t\t\/\/ store the employee\n\t\tempStore.put(result.value);\n\t\t\/\/ next employee ...\n\t\tresult.continue();\n\t};\n\n\t\/\/ error handling\n\tcursorRequest.onerror = companies.indexedDB.onerror;\n}\n<\/syntaxhighlight>",
	"architecture":"Please visit [[101implementation:html5local]], to get more informations about the architecture.",
	"usage":"* Check out all files from the repository\n* Open the index.html with your web-browser (check [[Language:HTML5|HTML5]] for the HTML5-support of your browser)\n\n[[Category:Web application]]"
},
{
	"name":"html5local",
	"summary":"[[web programming]] with [[Language:HTML5]]",
	"motivation":"This is a simple implementation of the basic [[101section:Features|101companies-features]] in [[Language:HTML5|HTML5]]. It provides [[client-side storage]] for the data, which are stored for more then one session. If you are interested in [[session storage]], look at [[101implementation:html5session]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"interaction"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"}],
	"technologies":[{"name":"Webbrowser"}],
	"illustration":"Most of the web application is written in [[Language:JavaScript|JavaScript]]. The data is stored in a storage-object (''localStorage''). During the session, this object provides string-based persistence..\n\n <syntaxhighlight lang=\"javascript\">\n var storageObject = localStorage;\n <\/syntaxhighlight>\n\nThe data-structure is defined with classes. The company contains departments and departments contain subdepartments and employees.\n\n <syntaxhighlight lang=\"javascript\">\n function Department (name) {\n \tthis.name = name;\n \tthis.employees = new Array();\n \tthis.subdepartments = new Array();\n }\n <\/syntaxhighlight>\n\nThe data-structure is a tree, which can be traversed to [[101feature:Cut|cut]] salaries or determine the [[101feature:Total|total]] of the whole company or individual departments. The tree can be stringified with [[Technology:JSON|JSON]] and stored in the storage-object. The example shows the [[101feature:Total|total]] feature for the company:\n\n <syntaxhighlight lang=\"javascript\">\n function totalCompany(company) {\n \tvar total = 0;\n \tvar len = company.departments.length;\n \tfor (var i = 0; i < len; i++) {\n \t\ttotal += totalDepartment(company.departments[i]);\n \t}\n \treturn total;\n }\n\n function totalDepartment(department) {\n \tvar total = 0;\n \tvar len = department.subdepartments.length;\n \tfor (var i = 0; i < len; i++) {\n \t\ttotal += totalDepartment(department.subdepartments[i]);\n \t}\n \tvar lenEmp = department.employees.length;\n \tfor (var i = 0; i < lenEmp; i++) {\n \t\ttotal += department.employees[i].salary;\n \t}\n \treturn total;\n }\n <\/syntaxhighlight>\n\nBecause of the \"stringification\" the objects do NOT have backward links, otherwise there would be infinite loops. Thats why some operations are more complicate and there is a need for a history-stack. This history-stack stores the index of the last visited department and the departments on the same level.",
	"architecture":"The application is implemented with [[Architecture:MVC|MVC]]. There are three views and models for each concern: company, department and employee. The implementation is very similar to [[101implementation:html5session]], [[101implementation:html5XMLHttpRequest]] and [[101implementation:html5indexedDatabase]], except that the model is implemented in different ways, concerning the data representation of the specific implementation. The main data access is managed in the ''company.js'', the specific models hold on to this.\n\nFor every object in the [[101feature:Company|data model]], there is a unique-id (unique for single company, department or employee) to grant reliable [[101feature:Interaction|Navigation]] between the different views.",
	"usage":"There are two possible ways to run this application:\n\n* Chrome: Just open the index.html with your web-browser\n* This HTML5-program does not work over file-protocol when using Firefox. In this case, you need access over http. To gain access over http, you can use, for example, XAMPP to create a webserver.\n\n# Download XAMPP from http:\/\/www.apachefriends.org\/en\/xampp.html\n# Install XAMPP\n# Deploy the index.html to your htdocs-directory (for example: E:\\xampp\\htdocs\\101implementation-html5\\)\n# Start the XAMPP-Control Panel and activate Apache\n# Start your web-browser\n# Call http:\/\/localhost\/101implementation-html5\/index.html\n\n[[Category:Web application]]"
},
{
	"name":"html5session",
	"summary":"[[web programming]] with [[Language:HTML5]]",
	"motivation":"This is a simple implementation of the basic [[101section:Features|101companies-features]] in [[Language:HTML5|HTML5]]. It provides [[client-side storage]] for the data, which are deleted after closing the session. Apart from that, it is mostly identical to [[101implementation:html5local]].\n\nFor more informations (concerning illustration, architecture and usage) please look at [[101implementation:html5local]].\n\n[[Category:Web application]]",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"}],
	"technologies":[{"name":"Webbrowser"}]
},
{
	"name":"html5tree",
	"summary":"[[web programming]] with [[Language:HTML5]], [[Language:JavaScript]], [[Language:php]] and [[Language:SQL]]",
	"motivation":"* A company with many departments and employees is not clearly arranged with the current [[101feature:Interaction#Navigation|navigation]]. Unlike, a treeview provides a complete overview of the whole company without exhausting much space in the GUI.\n* This implementation extends the [[101implementation:html5ajax|html5ajax]]-implementation with a treeview and a refitted [[101feature:Interaction|GUI]].\n* It also introduces new [[101feature:Create|create]]- and [[101feature:Delete|delete]]-features for the company.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"interaction"},
		{"name":"precedence"},
		{"name":"validation"},
		{"name":"visualization"}],
	"languages":[{"name":"HTML5"},
		{"name":"JavaScript"},
		{"name":"php"},
		{"name":"SQL"}],
	"technologies":[{"name":"MySQL"},
		{"name":"XAMPP"},
		{"name":"JSON"},
		{"name":"Apache_HTTP_Server"},
		{"name":"XMLHttpRequest"},
		{"name":"jQuery"},
		{"name":"Webbrowser"}],
	"illustration":"* To get an overview of the [[Technology:JSON]]-messages, visit the [[101implementation:html5ajax]] project.\n* This is an example for a [[Technology:JSON]]-message, which [[101feature:Delete|deletes]] a department:\n\n<syntaxhighlight lang=\"text\">\n{\n\t\"id\":1,\n\t\"table\":\"department\",\n\t\"action\":\"delete\"\n}\n<\/syntaxhighlight>\nThe simple request is received by the [[server-side]] [[Language:php]] script and deletes the department with the id 1 on the [[server]]. In this implementation, the cascading delete anchored in the database provides a recursive deletion for all containing subdepartments:\n\n<syntaxhighlight lang=\"php\">\n        $request = \"DELETE FROM department WHERE id = \" . $id;\n        mysql_query($request);\n<\/syntaxhighlight>",
	"architecture":"* The architecture is similar to [[101implementation:html5ajax]], except that most of the html-elements of the view are located in the [this!!index.html].\n* The needed elements for [[101feature:Company|departments]] and [[101feature:Company|employees]] are set visible as required.",
	"usage":"You need a web- and sql-server to use this application. In this tutorial both will be taken by XAMPP: http:\/\/www.apachefriends.org\/en\/xampp.html\n\nThis tutorial adopts some parts of [[101implementation:mySql]]. The company.sql and sampleCompany.sql are modified for this project. They are located in the \"sqlScripts\" folder.\n\n* Download and install XAMPP\n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"MySQL\"\n* Use the guideline of [[101implementation:mySql]] up to \"Populate tables...\" with the modified sql-scripts.\n\nAfter the database is running, follow the next steps:\n\n* To start the application, you need to download all project-files except the README\n* Put the files into the htdocs-directory of your XAMPP (a new sub-directory in \"htdocs\" is recommended)\n* Run index.html\n\nThe project is provided as a netbeans-project. If you want to change the code, you have to:\n\n* Download (http:\/\/netbeans.org\/) and install [[Technology:NetBeans]]\n* \"Open project\" and select the html5tree-folder\n\n[[Category:Web application]]"
},
{
	"name":"hxt",
	"summary":"tree-based XML processing with [[Technology:HXT]] in [[Language:Haskell]]",
	"motivation":"[[101feature:Company|Companies]] are represented in [[Language:XML]] and the [[Technology:HXT|Haskell XML Toolbox]] is used for processing such company XML data.\nThat is, we use HXT's rich combinator [[:Category:Library|library]] to formulate a query for [[101feature:Total|totaling]] and a transformation for [[101feature:Cut|cutting]] salaries in a given company XML tree. Totaling results are [[101feature:Mapping|mapped]] to <syntaxhighlight lang=\"haskell\" enclose=\"none\">Float<\/syntaxhighlight> values in [[Language:Haskell|Haskell]].\nThe concept of [[Arrow|arrows]] is demonstrated in this implementation, because the combinator library is heavily based on this concept. That is, we exercise arrow combinators and functions.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"},
		{"name":"mapping"}],
	"languages":[{"name":"XML"},
		{"name":"Haskell"}],
	"technologies":[{"name":"HXT"},
		{"name":"GHCi"}],
	"illustration":"In the following we will demonstrate the construction of an arrow for [[101feature:Total|totaling]] and how one can run this arrow in IO.\n\n=== Total ===\n\nWe define a query for totaling all company salaries:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxt\/Total.hs\" line>\ntotal :: ArrowXml a => a XmlTree Float\ntotal = listA (deep $ hasName \"salary\"\n               >>> \n               getChildren  \n               >>> \n               getText)     \n        >>>\n        arr (sum.(map read)) \n<\/syntaxhighlight>\nIn line 2 we query all salary nodes by using <syntaxhighlight lang=\"haskell\" enclose=\"none\">deep $ hasName \"salary\" :: ArrowXml a => a XmlTree XmlTree<\/syntaxhighlight>.\nThis is an arrow from <syntaxhighlight lang=\"haskell\" enclose=\"none\">XmlTree<\/syntaxhighlight> to <syntaxhighlight lang=\"haskell\" enclose=\"none\">XmlTree<\/syntaxhighlight>, say a filter for all salary nodes. In general  <syntaxhighlight lang=\"haskell\" enclose=\"none\">deep<\/syntaxhighlight> only finds non-nested results, but because of the fact that we are dealing with text nodes, which can not be nested, this is acceptable in this situation. In lines 2-6 the result of this arrow is then combined with <syntaxhighlight lang=\"haskell\" enclose=\"none\">getChildren >>> getText<\/syntaxhighlight> by using <syntaxhighlight lang=\"haskell\"  enclose=\"none\">>>><\/syntaxhighlight>. The new arrow of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">ArrowXml a => a XmlTree String<\/syntaxhighlight> returns the text of each salary node.\n\nWe then use ''Control.Arrow.ArrowList'''s <syntaxhighlight lang=\"haskell\" enclose=\"none\">listA<\/syntaxhighlight> in line 2 to collect all results from this arrow in an array, giving us a new arrow of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">ArrowXml a => a XmlTree [String]<\/syntaxhighlight>. \n\nIn line 7 the result of this arrow is passed to the lifted version of <syntaxhighlight lang=\"haskell\" enclose=\"none\">(sum.(map read)) :: (Read c, Num c) => [String] -> c<\/syntaxhighlight>, which in this case is of type: <syntaxhighlight lang=\"haskell\" enclose=\"none\">ArrowXml a => a [String] Float<\/syntaxhighlight>.\n\nThe overall emerging arrow, giving us the total salary, is of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">ArrowXml a => a XmlTree Float<\/syntaxhighlight>.\n\n=== Running an arrow ===\n\nWhen we combinate the arrow for reading a sample company from a XML file with the totaling arrow we get:\n<syntaxhighlight lang=\"haskell\" source=\"hxt\/Main.hs\">\nreadDocument [] \"sampleCompany.xml\" >>> total\n<\/syntaxhighlight>\nWe use <syntaxhighlight lang=\"haskell\" enclose=\"none\">runX :: IOSArrow XmlTree c -> IO [c]<\/syntaxhighlight> for running this arrow in IO. The function returns all results of a given arrow in a list. Because we except this list to be a singleton list, we can write:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxt\/Main.hs\">\n[ttl] <- runX ( readDocument [] \"sampleCompany.xml\" \n                >>> total )\n<\/syntaxhighlight>\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">ttl<\/syntaxhighlight> holds the total salary of a sample company.",
	"architecture":"[this!!Total.hs] provides the arrow for totaling salaries as described in the illustration section. [this!!Cut.hs] contains a transformation arrow for cutting salaries. [this!!Main.hs] collects test scenarios for totaling and cutting XML data provided by [this!!sampleCompany.xml]",
	"usage":"* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"hxtPickler",
	"summary":" [[H\/X mapping]] with  [[Technology:XML pickler|XML picklers]]",
	"motivation":"We exercise [[101feature:Mapping|mapping]] from Haskell to XML data by making use of [[Technology:HXT]]'s  [[Technology:XML pickler]] [[Arrow|arrows]] and functions. \nThat is, we declare <syntaxhighlight lang=\"haskell\" enclose=\"none\">XMLPickler<\/syntaxhighlight> instances for companies, departments and employees and define appropriate pickler functions. In this context we illustrate predefined picklers and pickler combinators. \nThis enables us to [[101feature:Serialization|serialize]] values of [[Algebraic datatype|algebraic datatypes]] for [[101feature:Company|companies]] as [[Language:XML|XML]] data.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"},
		{"name":"mapping"}],
	"languages":[{"name":"XML"},
		{"name":"Haskell"}],
	"technologies":[{"name":"HXT"},
		{"name":"XML pickler"},
		{"name":"GHCi"}],
	"illustration":"=== A Pickler for Companies ===\n\nTo define a pickler for companies we declare an instance of <syntaxhighlight lang=\"haskell\" enclose=\"none\">XMLPickler<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxtPickler\/Pickler.hs\">\ninstance XmlPickler Company where\n    xpickle = xpCompany\n<\/syntaxhighlight>\nThe pickler function <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpCompany<\/syntaxhighlight> is defined as follows:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxtPickler\/Pickler.hs\" line>\nxpCompany :: PU Company\nxpCompany \n      = xpElem \"company\" $\n        xpWrap ( uncurry Company\n               , \\c -> ( cname c\n                       , depts c\n                       )\n                ) $\n        xpPair  (xpAttr \"name\" xpText)\n                (xpList xpickle)\n<\/syntaxhighlight>\nFor implementing <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpCompany<\/syntaxhighlight> we use <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpElem<\/syntaxhighlight> in line 3.\nBy using this function we define that a company, represented in XML, should be inside a XML tag labeled \"company\". The pickler for the content of the tag is defined by the second argument of <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpElem<\/syntaxhighlight>.\n\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">xpWrap<\/syntaxhighlight> is of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">(a -> b, b -> a) -> PU a -> PU b<\/syntaxhighlight>. \nIt returns a Pickler (PU) for <syntaxhighlight lang=\"haskell\" enclose=\"none\">b<\/syntaxhighlight> and expects a pair of functions from <syntaxhighlight lang=\"haskell\" enclose=\"none\">a<\/syntaxhighlight> to <syntaxhighlight lang=\"haskell\" enclose=\"none\">b<\/syntaxhighlight> and vice versa and a Pickler for <syntaxhighlight lang=\"haskell\"  enclose=\"none\">a<\/syntaxhighlight> (<syntaxhighlight lang=\"haskell\" enclose=\"none\">PA a<\/syntaxhighlight>).\n\nIn lines 4-8 the first part of the first argument of the wrapping pickler is <syntaxhighlight lang=\"haskell\" enclose=\"none\">uncurry Company<\/syntaxhighlight>. It defines how to construct a <syntaxhighlight lang=\"haskell\" enclose=\"none\">Company<\/syntaxhighlight> value from a pair of name and departments. The second part of the pair defines the opposite direction: How to disassemble a company into its components.\n\nThe second argument of <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpWrap<\/syntaxhighlight> in lines 9-10 defines the actual pickler for the (name, departments) pair (this is <syntaxhighlight lang=\"haskell\" enclose=\"none\">PA a<\/syntaxhighlight> in the type signature of the wrapping pickler). \nWe use the combinator for pairs <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpPair :: PU a -> PU b -> PU (a, b)<\/syntaxhighlight>. The pickler for the company name is defined by using a pickler for XML attributes and a pickler for text. That is, the company name should be an attribute of the \"company\" tag.\nThe pickler for the list of departments is defined by making use of a combinator for lists and <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpickle<\/syntaxhighlight>.\nBecause of type inference and because we also declare a <syntaxhighlight lang=\"haskell\" enclose=\"none\">XMLPickler<\/syntaxhighlight> instance for departments, Haskell will choose the appropriate pickler function for departments.\n\n=== Pickling a Company ===\n\nPickling a company is realized by using arrows:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxtPickler\/Main.hs\">\nrunX ( constA company \n       >>>\n       xpickleDocument xpCompany [withIndent yes] $ \n       \"sampleCompanyCut.xml\"\n     )\n<\/syntaxhighlight>\nA lifted sample company is passed to the arrow for pickling a document. In this case <syntaxhighlight lang=\"haskell\" enclose=\"none\">xpickleDocument<\/syntaxhighlight> expects a pickler for companies, some writing options and a file name.\n\n=== Unpickling a Company ===\n\nTo unpickle a company the arrow function <syntaxhighlight lang=\"haskell\" enclose=\"none\">xunpickleDocument<\/syntaxhighlight> is used:\n\n<syntaxhighlight lang=\"haskell\" source=\"hxtPickler\/Main.hs\">\n[company1] <- runX ( xunpickleDocument xpCompany $ \n                     [withRemoveWS yes] $ \n                     \"sampleCompany.xml\" )\n<\/syntaxhighlight>\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">runX<\/syntaxhighlight> returns a list of arrow results, which we except to be a singleton list. On success <syntaxhighlight lang=\"haskell\" enclose=\"none\">company1<\/syntaxhighlight> should hold the unpicklered company.",
	"architecture":"[this!!Pickler.hs] holds the pickler definitions for companies, departments and employees. The algebraic datatype for companies can be found in [this!!Company.hs].[this!!Total.hs] and [this!!Cut.hs] provide totaling and cutting functionality. [this!!sampleCompany.xml] holds a sample company. [this!!Main.hs] collects test scenarios for pickling\/unpickling, totaling and cutting companies.",
	"usage":"* [this!!Main.hs] has to be loaded into GHCi. \n* The <syntaxhighlight lang=\"haskell\" enclose=\"none\">main<\/syntaxhighlight> function has to be applied.\n* The output should be equal to the content of the file [this!!baseline].\nOne can also use the [this!!Makefile] with a target ''test'' for [[test automation]]."
},
{
	"name":"javaComposition",
	"summary":"basic OO programming in [[Language:Java]]",
	"motivation":"Basic style of [[OO programming]] is applied. A simple [[object model]]\nis provided for [[101feature:Company]]. The object model leverages \n[[object composition]] to compose companies from (nested) departments\nand employees. (No [[class inheritance]] is exercised, but see \n[[101implementation:javaInheritance]] for a variation that indeed leverages class\ninheritance.) The operations for [[101feature:Total]] and\n[[101feature:Cut]] are implemented as [[:Category:instance method]]s on\nthe classes for companies, departments, and employees. Further, \n[[101feature:Serialization]] is implemented with the help of Java's\n[[Technology:Object Streams]]. To this end, the \n[[Marker interface pattern|marker interface]] ''Serializable'' is applied \nto the classes of the object model for companies. This form of serialization\ncounts as [[closed serialization]] because the serialization format is\ndefinitely Java-specific.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"The classes for companies, departments, and employees\nall model [[POJO]]s. It follows a sketch of the class for companies \nwith fields and properties for company name and its list of departments\nas well as methods for totaling salaries and cutting them in\nhalf. Thus:\n\n<syntaxhighlight lang=\"java\">\npublic class Company implements Serializable {\n  private static final long serialVersionUID = ...;\n  private String name;\n  private List<Department> depts;\n  public String getName() { ... }\n  public void setName(String name) { ... }\n  public List<Department> getDepts() { ... }\n  public Double total() { ... }\n  public void cut() { ... }\n}\n<\/syntaxhighlight>\nHere is the implementation of ''cut''; basically, the\noperation is delegated to the individual departments,\nand the operation is implemented as an [[impure computation]]\nwith a void method:\n\n<syntaxhighlight lang=\"java\">\npublic void cut() {\n  for (Department d : getDepts())\n    d.cut();\n}\t\n<\/syntaxhighlight>",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]]\nwith the methods for [[101feature:Total]] and [[101feature:Cut]]. Some boilerplate\ncode for [[101feature:Serialization]] and testing its correct implementation is to \nbe found in package ''org.softlang.serialization''. Package ''org.softlang.tests'' \nhosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n** Run class ''Serialization'' with JUnit to exercise serialization."
},
{
	"name":"javaExorcism",
	"summary":"excessive illustration of design patterns in Java",
	"motivation":"Consider [[101implementation:javaVisitor]] and [[101implementation:javaTemplate]] for simpler \nimplementations that also put to work some design patterns for illustrative purposes. The present\nimplementation is somewhat extreme in that it aims to illustrate a larger number of design patterns\npossibly for the argument's sake, without strong practical incentive. So please be careful about consuming\nthis implementation. Please also observe the name of this implementation, \"...Exorcism\", which is supposed to be a clear\nhint at the common danger of over-engineering a design. One way of going over the top is to prematurely\nweave an additional design pattern into a system without understanding the pros and cons of doing so, \nwithout actually establishing the proper incentive of deploying the pattern. To summarize, the \npresent implementation stands out with its design density in terms of the number of patterns and their\npattern interactions as they are provoked, encountered, and addressed.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"logging"},
		{"name":"access control"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"architecture":"Package ''org.softlang.company'' and subpackages hosts two object models for [[101feature:Company]].\nPackage ''org.softlang.features'' hosts feature implementations.\nPackage ''org.softlang.tests'' hosts JUnit tests; see below.\nPackage ''org.softlang.util'' hosts library-like extensions (thereby extending ''java.util'').\nAll the remaining packages host pattern infrastructure and pattern instances.\n\n=== Abstract Factory pattern ===\n\nPackage ''org.softlang.company'' defines the company object model in an interface-oriented manner.\nThere are two alternative implementations of these interfaces. That is, package ''org.softlang.company.impl.pojo'' provide a\nsimple, POJO-like implementation, whereas ''org.softlang.company.impl.bean'' implements objects with observability (in the sense \nof the ''Observable'' class of package ''java.util'') and a parent axis. Client code can be parametric in the implementation on \nthe grounds of factories of package ''org.softlang.company.factory''. For instance, the code for constructing a sample company \nuses a factory parameter; see the ''Basics'' class of package ''org.softlang.tests''. Some client code only works for one of the\ntwo implementations. For instance, the logging feature of package ''org.softlang.features'' relies on objects with observability \nspecifically.\n\n=== Adapter pattern ===\n\nA class adapter is used when deriving the ''DepartmentImpl'' class of package ''org.softlang.company.impl.bean''\nfrom the ''ContainerImpl'' class of the same package such that it implements the ''Department'' class of package ''org.softlang.company''.\nAn object adapter is used when down-grading the ''List'' interface of package ''java.util'' the interface ''SimpleList'' of\npackage ''org.softlang.util'' such that much less methods are exposed for the rest of this projects. For instance, \nthe class ''ObservableSimpleList'' of package ''org.softlang.util'' only implements the narrow interface.\n\n=== Command pattern === \n\nThe cut operation is implemented twice: once in package ''org.softlang.features'' and once in package\n''org.softlang.command''. The later implementation uses command objects to defer the execution of the cut operation. To this\nend, each employee is encapsulated in an command object of class ''CutEmployee'' and the batch of the derived command objects for\nemployees is maintained by a command object of class ''CutCompany''. All command objects provide ''execute'' and ''undo'' actions.\nIn particular, command objects for individual employees back up the salary before they cut.\n\n=== Composite pattern ===\n\nA company is a composite structure that breaks down into departments, employees, and their properties.\nThere is a rooting interface ''Component'' that provides the setter and getter for a name that is equally available on \ncompanies, departments, and employees. In the case of the package ''org.softlang.company.impl.bean'', there are even additional\nshared methods because of the rooting class ''java.util.Observable''. In this case, overriding is also leveraged so that \naddition and removal of observers is pushed into sub-components in the case of composite-like as opposed to leaf-like\ncomponents.\n\n=== Decorator pattern ===\n\nThe ''ObservableSimpleList'' class of package ''org.softlang.util'' effectively decorates a given (simple)\nlist with observability (in the sense of the ''Observable'' class of package ''java.util''). That is, an observable (simple) list\ncombines the interfaces of (simple) lists and ''Observable''. The ''ObservableSimpleList'' class wraps the underlying (simple) \nlist and it also incorporates additional state because it derives from the ''Observable'' class which manages observers (listeners).\nObservable (simple) lists are used in the non-POJO implementation of the company object model. That is, the list of subunits \nfor companies and departments is set up to be observable.\n\n=== Observer pattern ===\n\nThere is clearly value in making company object structure observable (in the sense of the ''Observable'' \nclass of package ''java.util''). For instance, if we were providing a GUI, observability would help with implementing an \nMVC architecture. In this implementation, observability is leveraged for [[101feature:Logging]] and [[101feature:Precedence]];\nsee the corresponding classes of package ''org.softlang.features''. Objects of the company object model are made observable \nin a way that gives credit to the part-whole structure. That is, registration of an observer with a company object is \npropagated down into all components. To this end, an observable (simple) list type is also used; see the ''ObserableSimpleList'' \nof package ''org.softlang.util''.\n\n=== Proxy pattern === \n\n[[101feature:Access control]] is implemented in a way that access to employee salaries is regulated. Proxy objects are used to \nto enforce the access control policy. By default, read and write access is enabled, but it can be configured even once the proxies\nhave been deployed. All concrete classes of the object model for companies are proxied. That is, employees are proxied because\ntheir get\/set salary members must be directly controlled, while departments and companies are proxied so that any added\nsubunit will be transparently proxied. To summarize, company objects are initially and continuously enhanced to provide proxies\nfor every component so that all salary access must go through access control.\n\n=== Singleton pattern ===\n\nWe use functor objects for the sake of parameterizing traversal functionality in monoids; see classes \n''Monoid'' and ''AddDoubles'' of package ''org.softlang.util''. Those functor objects are good candidates for singletons;\nsee the implementation of ''AddDoubles''. There is a static member ''getInstance'' to retrieve the singleton, which is constructed\nupon request, if needed, or fetched from a static field otherwise. The use of a singleton helps here to emphasize the fact that\nno state is associated with monoids.\n\n=== Template pattern ===\n\nThe cut operation can be understood as a \"walk\" over the company structure with a mutation to be applied\nto any employee encountered. Likewise, the total operation can be understood as a \"reduction\" or a \"query\" over the company\nstructure where salaries are extracted from any employee encountered and those salaries are combined systematically. Package\n''org.softlang.template'' captures the general notions of walkers and reducers as template methods. The primitive operations\nof these templates are to be defined by visit methods of an appropriate visitor. The template methods essentially compose\nthe client visitors with traversal behavior. See the implementations of cut and total in package ''org.softlang.features''.\n\n=== Visitor pattern ===\n\nNearly all operations including those for totaling and cutting salaries are implemented as visitors; see package\n''org.softlang.visitor'' for the visitor framework. There are two kinds of visitors: void visitors, i.e., visitors with\nvoid visit methods as well as returning visitors, i.e., visitors with visit methods with some uniform result type. \nThe use of visitors is deeply integrated into the rest of this implementation. In particular, the template methods of\npackage ''org.softlang.template'' also leverage visitors. Arguably, visitors are needed for the chosen object model because\nthere is polymorphism propperly involved due to the abstract ''Subunit'' class with the concrete subclasses \n''Employee'' and ''Department''.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** For instance, run class ''Basics'' with JUnit to exercise basic features.\n** See the documentation of the other test cases.",
	"issues":"Additional patterns should be considered:\n* State pattern\n* Memento pattern\n* Strategy pattern\n* ..."
},
{
	"name":"javaInheritance",
	"summary":"basic OO programming in [[Language:Java]]",
	"motivation":"Basic style of [[OO programming]] is applied. A simple [[object model]]\nfor companies is provided with [[method]]s to implement a [[query]] for\ntotaling salaries and a [[:Category:transformation]] for cutting salaries.\nIn fact, [[class inheritance]] is leveraged, but see [[101implementation:javaComposition]] \nfor a variation that uses [[object composition]]. Because of the use of class\ninheritance, the aforementioned methods are actually [[virtual method]]s.\nBasic [[:Category:serialization]] in the sense of [[Technology:Object Streams]] \nis enabled by means of the [[Marker interface pattern|marker interface]]\n''Serializable'', which is applied to the [[:Category:class]]es of the object model \nfor companies.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"architecture":"Package ''org.softlang.company'' hosts the object model for companies\nwith virtual methods for [[101feature:Total]] and [[101feature:Cut]]. Some \nboilerplate code for [[101feature:Serialization]] is implemented in the class \n''org.softlang.features.Serialization'' (see methods ''readObject'' and ''writeObject'').\nPackage ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available as the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n** Run class ''Serialization'' with JUnit to exercise serialization."
},
{
	"name":"javaLexer",
	"summary":"[[:Category:lexer]]-based text processing in [[Language:Java]]",
	"motivation":"A simple custom-made lexer is used to process a text-based representation of companies.\nThe lexer uses a lookahead of 1.\nThe lexer reports all tokens including whitespace.\n[[101feature:Total]] is implemented by means of finding token sequences \nconsisting of keyword \"salary\" followed by a number while ignoring whitespace\nin between. (Just looking for a number would be sufficient for the situation at hand\nbecause numbers are used for salaries only, but the extra test makes the\npoint that ad hoc tests may be needed when lexers are used for data processing.)\n[[101feature:Cut]] copies lexemes to an output stream while\nmodifying salaries. The lexemes for whitespace token transport layout from \ninput to ouput. Because of the combination of lexer and pretty printing, \nit is fair to say that the implementation covers [[101feature:Serialization]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations.\n** Run class ''Noop'' with JUnit to exercise positive and negative test cases for the lexer."
},
{
	"name":"javaMultithreading",
	"summary":"Multithreading implementation in [[Language:Java]].",
	"motivation":"''This project was created at the PTT-Hackathon 2011.''\n\nMultithreading grants simultaneously executed multiple access to the [[101companies:System]]. This is usefull for multiclient-applications, in which it is possible to initiate different changes at the same time. The project uses the [[Technology:Monitor|monitor]]-concept of [[Language:Java]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"Multithreading"}],
	"illustration":"The actions [[101feature:Cut|cut]] and [[101feature:Total|total]] are encapsulated in the execute-method of the ConcurrentContext. The synchronization of the execute-method allows only one execution at a time.\n\n<syntaxhighlight lang=\"java\">\n\tpublic synchronized <X, Y> void execute(final Action<X, Y> action,\n\t\tfinal X param) {\n\n\t\tfinal ConcurrentContext context = this;\n\t\tpool.submit(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\taction.execute(context, param);\n\n\t\t\t}\n\t\t});\n\n\t}\n<\/syntaxhighlight>\nEach action calls the method cut or total of the company. The specific method runs through the department-list and cuts the current department or adds the total of all related departments.\n\n<syntaxhighlight lang=\"java\">\n\tpublic Double total() {\n\t\tdouble total = 0;\n\t\tfor (Department d : getDepts()) {\n\t\t\ttotal += d.total(); \/\/ the total-method in department is similar to this one\n\t\t}\n\t\treturn total;\n\t}\n<\/syntaxhighlight>",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]]. The methods for [[101feature:Total]] and [[101feature:Cut]] are implemented as classes named Actions and hosted in ''org.softlang.action''. They implement the basic Action\ninterface [this!!src\/org\/softlang\/action\/Action.java Action.java]. These can be used with a descendant of the interface Context hosted in ''org.softlang.context''. There are two implementations: [this!!src\/org\/softlang\/context\/ConcurrentContext.java ConcurrentContext.java] and [this!!src\/org\/softlang\/context\/SequentialContext.java SequentialContext.java].  The methods should be called with [this!!src\/org\/softlang\/context\/CompanyContextManager.java CompanyContextManager.java], which organizes the call on all direct connected departments. The class [this!!src\/org\/softlang\/tests\/CompanyCreator.java CompanyCreator.java] ensures adequate large companies for testing to (hopefully) see the boost of multithreading. There is an internal timeout if we have a [this!!src\/org\/softlang\/action\/TotalAction.java TotalAction.java] to ensure all threads are finished before returning the result;",
	"usage":"* The implementation is provided as an Eclipse project. \n* Open the project with Eclipse; this will also build the project:\n** Run class ''Basics'' with JUnit to exercise basic features and ensure working of CompanyCreator.\n** Run class ''Threads'' with JUnit to exercise threading."
},
{
	"name":"javaParseLib",
	"summary":"parse companies with parser combinators in Java ",
	"motivation":"By using functor objects systematically, we can define a combinator\nlibrary for (top-down) parsing. In fact, two scenarios are supported:\nplain acceptance versus proper parsing into an intermediate representation.\nThere are acceptor and parser combinators for all common EBNF\nconstructs as well as building blocks for lexical analysis. \nThe parser for [[101companies:System]] actually implements \n[[101feature:Total]]. That is, salaries are totaled as the company\nis parsed.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"parsing"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"architecture":"* Folder ''input'' hosts valid and invalid input files for the companies acceptor\/parser.\n* Package ''javaf.prelude'' hosts basic functor types for functional OO programming.\n* Package ''parseLib.acceptor'' hosts combinators for acceptors.\n* Package ''parseLib.parser'' hosts combinators for parsers.\n* Package ''parseLib.util'' hosts general utilities.\n* Package ''org.softlang.parser'' hosts lexer, acceptor, and parser for companies.\n* There are also two ''...tests'' packages with JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the following packages:\n** Package ''org.softlang.tests'' tests the companies acceptor and parser.\n** Package ''parseLib.tests'' tests the combinator library in some basic way.",
	"issues":"Class ''Input'' of package ''parseLib.util'' should be replaced by \nsome class of the framework."
},
{
	"name":"javaParser",
	"summary":"recursive-descent parsing in [[Language:Java]]",
	"motivation":"Recursive-descent parsing is used to process a text-based representation of companies.\nThe underlying lexer is custom-made, too.\nBoth lexer and parser use a lookahead of 1.\nThe lexer reports all tokens excluding whitespace.\nThe parser relies on protected handler methods to allow for injection of semantic actions.\nFor instance, [[101feature:Total]] is implemented by defining the handler for employees to aggregate salaries.\nThe implementation of [[101feature:Cut]] requires ad hoc pretty printing.\nBecause of the combination of parsing and pretty printing, \nit is fair to say that the implementation covers [[101feature:Serialization]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"architecture":"Package ''org.softlang.parser'' hosts all components for parsing: a lexer, an enum type for tokens,\nand a parser that can be customized with semantic actions by class inheritance. (The lexer is essentially c\nopied from [[101implementation:javaLexer]] except that whitespace is skipped.) Package \n''org.softlang.operations'' hosts implementations of [[101feature:Total]] and [[101feature:Cut]].\nPackage ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations.\n** Run class ''Noop'' with JUnit to exercise positive and negative test cases for the parser."
},
{
	"name":"javaRmi",
	"summary":"Distribute company objects with RMI in Java",
	"motivation":"We can think of the server as a centralized information system that maintains a number of companies.\nWe can also think of the server as the information system for a given company.\nIn both cases, the client remote accesses the company objects.\nFor instance, the calculation of the salary total is to be done by the server.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"distribution"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"Java RMI"}],
	"architecture":"Package ''org.softlang.shared.company'' defines interfaces for the company object model.\nThe members of these interfaces have a throws declaration for remote exceptions.\nAlso, the interfaces derive from the Remote interface.\nPackage ''org.softlang.server.company'' implements the aforementioned interfaces as POJOs with methods for total and cut.\nThere is also Factory class in that package for convenience.\nThe class ''Server'' in the package ''org.softlang.server'' implements an (RMI) server.\nTo this end, a sample company is bound in the registry.\nThe server keeps on running until terminated explicitly.\nThe class ''Client'' in the package ''org.softlang.client'' implements an (RMI) client.\nTo this end, the sample company is looked up from the server.\nMethods for totaling and cutting salaries are executed on the resulting proxy object.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* The simple scenario of running server and client on the same machine is exercised as follows:\n** Start the server from the command line; see the Makefile.\n** Start the client from within Eclipse; class ''org.softlang.client.Client''.\n** Both server and client produce some standard output.\n** The client terminates automatically, and can be restarted any number of times.\n** The server must be terminated explicitly at the command line.\n\n=== General tips and tricks on RMI ===\n\na) Running the applications\n\nEven if you are not using make, look at the Makefiles for illustration.\n\nb) Running both server and client on the local machine.\n\nThe following advice may be helpful in running both the client and the\nserver parts of an RMI application on a single machine. When you use\nRMI, and you want to connect in the client to the server, you need to\nknow the IP address (hostname) of the server. For testing purposes, it\nis indeed common to run both client and server on the same\nmachine. One typically refers to the given machine by localhost or\n127.0.0.1, but depending on network setup, the actual IP address\nor the DNS-resolvable machine name may (need to) be used.\n\nc) Ports and firewall exceptions\n\nRMI requires some ports to be accessible.\n\nAlso RMI may require special firewall settings.\n\nRMI uses port 1099 by default.\nSee: \"LocateRegistry.createRegistry(Registry.REGISTRY_PORT);\"\nAll ports from 1024 may be used.\n\nIn Windows, the following firewall exceptions may be needed:\n C:\\WINDOWS\\system32\\java.exe\n C:\\Programme\\Java\\jdk1.6.0_06\\bin\\rmiregistry.exe\n C:\\Programme\\Java\\jdk1.6.0_06\\bin\\java.exe\n\nd) Security policy\n \nThe server of the application is started with a security manager.\nSee org.softlang.server.Server.java.\nHence we *must* grant some RMI-related rights; see file security.policy.\nAlso, the policy file must be passed to the server.\nSee Makefile.\nThe policy is very permissive; see the wildcard."
},
{
	"name":"javaScanner",
	"summary":"[[:Category:lexer]]-based text processing in [[Language:Java]]",
	"motivation":"A simple custom-made lexer is used to process a text-based representation of companies.\nThe lexer leverages Java's basic Scanner API.\nHence, it uses a delimiter pattern to chop the input into candidate tokens;\nit then uses regular expressions to recognize specific tokens. \nThe default delimiter pattern is used: whitespace.\nThis also means that whitespace itself is not reported as a token.\n[[101feature:Total]] is implemented by means of finding token sequences \nconsisting of keyword \"salary\" followed by a number.\n(Just looking for a number would be sufficient for the situation at hand\nbecause numbers are used for salaries only, but the extra test makes the\npoint that ad hoc tests may be needed when lexers are used for data processing.)\n[[101feature:Cut]] copies lexemes to an output stream while\nmodifying salaries and performing some ad hoc pretty printing.\nBecause of the combination of lexer and pretty printing, \nit is fair to say that the implementation covers [[101feature:Serialization]].\n\n'''Note:''' Because of the issue identified below, this is essentially a \nsuboptimal implementation. See [[101implementation:javaLexer]] for a more\nrobust lexer-based implementation in Java.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"java.util.Scanner"}],
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations.\n** Run class ''Noop'' with JUnit to exercise positive and negative test cases for the lexer.",
	"issues":"Given java.util.Scanner's approach to scanning with its reliance \non delimiters, it is not straightforward to support proper string literals. The problem\nis that the straightforward token delimiter, whitespace, can also occur inside\n(proper) strings. No other definition of delimiter, not even a dynamically changing\ndefinition seem to be applicable here. Hence, the present implementation simply \ndoes not allow spaces in string literals---which is clearly a major limitation."
},
{
	"name":"javaStatic",
	"summary":"modular programming with [[:Category:static method]]s in [[Language:Java]]",
	"motivation":"The present  implementation can be viewed as a variation on [[101implementation:javaComposition]]. \nOperations on companies are implemented as families of static methods in extra classes. \nThis is straightforward '''if''' the operations are not polymorphic. \nThis is necessarily the case for the given object model only uses object composition as opposed to \nclass inheritance or interface polymorphism.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"A designated class with static methods for ''cut'' is defined as follows:\n\n<syntaxhighlight lang=\"java\">\npublic class Cut {\n\tpublic static void cut(Company that) {\n\t\tfor (Department d : that.getDepts())\n\t\t\tcut(d);\n\t}\t\n\tpublic static void cut(Department that) {\n\t\tcut(that.getManager());\n\t\tfor (Department s : that.getSubdepts())\n\t\t\tcut(s);\n\t\tfor (Employee e : that.getEmployees())\n\t\t\tcut(e);\n\t}\t\n\tpublic static void cut(Employee that) {\n\t\tthat.setSalary(that.getSalary() \/ 2);\n\t}\t\n}\n<\/syntaxhighlight>",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]]\nand the general interfaces for void and returning visitors on companies, departments,\nand employees. Package ''org.softlang.features'' hosts implementations of the basic \noperations [[101feature:Total]] and [[101feature:Cut]] as well as some boilerplate\ncode for [[101feature:Serialization]]. Package ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n\nThe sample data is retrieved from the file ''sampleCompany.ser''.\n\nThe latter file was saved with [[101implementation:javaComposition]]."
},
{
	"name":"javaSyb",
	"summary":"exercise [[SYB]]-style generic programming with reflection in Java",
	"motivation":"When implementing operations for totaling or cutting salaries in a regular object-oriented fashion (such as in the case of [[101implementation:javaComposition]]), it occurs that the implementations are unnecessarily concerned with the detailed object model. In contrast, some XML-based implementations (such as in the case of [[101implementation:javaDom]]) are much more concise because they can leverage extra query facilities, in fact, axes, such as the descendants axis of XPath. The [[SYB]] style of generic programming also provides such conciseness on the grounds of functional programming idioms. In particular, queries and transformations are supported by customizable traversal schemes.  Conceptually, these are higher-order functions that are to be parametrized by essential, problem-specific first-order functions. The present implementation applies SYB to Java. The implementation includes a simple [[SYB]]-style library for object traversals. The library relies on reflection, in fact, introspection--as provided by Java's reflection approach.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"Here is the complete implementation of [[101feature:Cut]].\n\n<syntaxhighlight lang=\"java\">\npublic class Cut {\n\n\tpublic static void cut(Company c) {\n\t\teverywhere(orIdentity(updateSalary())).apply(c);\n\t}\t\n\t\n\tpublic static Action<Employee> updateSalary() {\n\t\treturn new Action<Employee>() {\n\t\t\tpublic void apply(Employee x) {\n\t\t\t\tx.setSalary(x.getSalary() \/ 2);\n\t\t\t}\n\t\t};\n\t}\n}\n<\/syntaxhighlight>\nThat is, we leverage the ''everywhere'' scheme of transformation which attempts to apply an argument transformation to each and every (sub-) object. The argument transformation is essentially a void method, but it is rendered here as an instance of a designated ''Action'' type.",
	"architecture":"* Package ''javaf.prelude'' defines some basic function \/ action types that are needed for 101companies example.\n* Package ''javaf.syb'' defines the query and transformation schemes needed. This is the cool code!\n* Package ''org.softlang.company'' hosts an object model for companies; adopted from [[101implementation:javaComposition]].\n* Operations are not defined as instance methods on the object model.\n* Package ''org.softlang.features'' totals and cuts salaries in SYB style.\n* File ''sampleCompany.ser'' is a serialized sample company; adopted from [[101implementation:javaComposition]].\n* Package ''org.softlang.tests'' contains JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise some operations including basic features.",
	"issues":"Naturally, any approach which uses reflection so heavily for data access \nhas inferior performance compared to approaches with more direct data access.\nThere are generative approaches that provide similar programming convenience\nwhile avoiding indeed reflection."
},
{
	"name":"javaTemplate",
	"summary":"illustration of the Template design pattern in Java",
	"motivation":"We identify templates for queries and transformations over companies.\nWe instantiate those templates for totaling and cutting salaries.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]].\n(These classes were adopted from [[101implementation:javaComposition]] with the\ninstance methods for totaling and cutting removed.)\nPackage ''org.softlang.template'' hosts the templates for queries and transformations.\nPackage ''org.softlang.features'' hosts the features [[101feature:Total]] and [[101feature:Cut]].\nPackage ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n** Run class ''Serialization'' with JUnit to exercise serialization."
},
{
	"name":"javaTree",
	"summary":"Tree based implementation in [[Language:Java]].",
	"motivation":"''This project was created at the PTT-Hackathon 2011.''\n\nThe tree-based view allows the user to get a large overview of the hierarchy of the [[101companies:System]]. The tree allows easy [[101feature:Interaction#Navigation|navigation]] within this hierarchy. The tree also provides quick adjustment on changes of the [[101feature:Company|company]] data.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"Swing"}],
	"illustration":"The main features [[101feature:Cut]], [[101feature:Total]] and [[101feature:Company]] are adopted from [[101implementation:javaInheritance]]. The main difference to [[101implementation:swing]] is, that the [[101feature:Interaction#Navigation|navigation]] is simplified with a tree view. This tree has to be initialized recursively with the company as root:\n\n<syntaxhighlight lang=\"java\">\n\/*\n * This method initializes the tree-view.\n *\/\nprivate Component createTree() {\n\tCompany company = model.getCompany(); \/\/ get company data\n\n\tDefaultMutableTreeNode root = new DefaultMutableTreeNode(company); \/\/ create root element\n\n\tfor (Department d : company.getDepts()) { \/\/ run through the departments and add them to the root\n\t\troot.add(addDepartmentNode(d)); \/\/ create department subtrees\n\t}\n\n\ttree = new JTree(root);\n\n\treturn new JScrollPane(tree); \/\/ return the JTree within a scroll pane\n}\n<\/syntaxhighlight>\nThe department subtrees are created in a similar way.",
	"architecture":"The main architecture of this project is [[Architecture:MVC|MVC]]. The class [this!!org\/softlang\/tests\/Interaction.java Interaction.java] starts the application and creates the main parts of the [[Architecture:MVC|MVC]]-structure: The [this!!org\/softlang\/swing\/view\/MainView.java MainView.java] creates the tree and provides a container for the single views of the company, departments and employees. These views are initialized by the [this!!org\/softlang\/swing\/controller\/Controller.java Controller.java] while the data and the selected element of the tree is stored in the [this!!org\/softlang\/swing\/model\/Model.java Model.java]. The main features [[101feature:Cut]] and [[101feature:Total]] can be found in ''org.softlang.operations'' while the classes for the data structure are in ''org.softlang.company''.",
	"usage":"* This project is provided as an [[Technology:Eclipse]] project.\n* After importing the project into [[Technology:Eclipse]] as ''Java Project'', just run Interaction.java as ''Java Application''."
},
{
	"name":"javaVisitor",
	"summary":"modular programming with [[Visitor pattern|visitors]] in [[Language:Java]]",
	"motivation":"The present  implementation can be viewed as a variation on [[101implementation:javaInheritance]]. \nThe [[Visitor pattern]] is applied to implement operations modularly. \nTo this end, two visitor interfaces are defined: one for ''void'' visitors (that\ndo not return any values), another one for ''returning'' visitors (with a designated\ntype parameter for the result type). Indeed, [[101feature:Total]] calls\nfor a returning visitor whereas [[101feature:Cut]] can be expressed as\na void visitor---if an [[impure computation]] is assumed.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"The interface for void visitors looks as follows:\n\n<syntaxhighlight lang=\"java\">\npublic interface VoidVisitor {\n\tvoid visit(Company o);\n\tvoid visit(Department o);\n\tvoid visit(Employee o);\t\t\n}\n<\/syntaxhighlight>\nFor comparison, here is the interface for returning visitors:\n\n<syntaxhighlight lang=\"java\">\npublic interface ReturningVisitor<R> {\n\tR visit(Company o);\n\tR visit(Department o);\n\tR visit(Employee o);\n}\n<\/syntaxhighlight>\nThe classes of the object model for companies do not implement\nany operations of the [[101companies:System]], but instead they\nare able to apply a given visitor to an object. For example:\n\n<syntaxhighlight lang=\"java\">\npublic class Department implements Serializable {\n\n\t\/\/ fields, getters, and setters omited\n\n\tpublic void accept(VoidVisitor v) { v.visit(this); }\n\tpublic <R> R accept(ReturningVisitor<R> v) { return v.visit(this); }\n}\n<\/syntaxhighlight>\nHere is the implementation of ''cut'' as a void visitor:\n\n<syntaxhighlight lang=\"java\">\npublic class Cut implements VoidVisitor {\n\n\tpublic void visit(Company o) {\n\t\tfor (Department d : o.getDepts())\n\t\t\td.accept(this);\n\t}\t\n\tpublic void visit(Department o) {\n\t\to.getManager().accept(this);\n\t\tfor (Subunit s : o.getSubunits())\n\t\t\ts.accept(this);\n\t}\n\tpublic void visit(Employee o) {\n\t\to.setSalary(o.getSalary() \/ 2.0d);\t\t\n\t}\t\n}\n<\/syntaxhighlight>",
	"architecture":"Package ''org.softlang.company'' hosts the object model for [[101feature:Company]]\nand the general interfaces for void and returning visitors on companies, departments,\nand employees. Package ''org.softlang.features'' hosts implementations of the basic \noperations [[101feature:Total]] and [[101feature:Cut]] as well as some boilerplate\ncode for [[101feature:Serialization]]. Package ''org.softlang.tests'' hosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n\nThe sample data is retrieved from the file ''sampleCompany.ser''.\n\nThe latter file was saved with [[101implementation:javaInheritance]]."
},
{
	"name":"javawsClient",
	"summary":"Implementing Web services in [[Language:Java]] (client side)",
	"motivation":"",
	"features":[],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"",
	"architecture":"This client consumes Java Web service that provides 101companies features.",
	"usage":"* The implementation is provided as an Eclipse project."
},
{
	"name":"javawsServer",
	"summary":"Implementing Web services in [[Language:Java]] (server side)",
	"motivation":"",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"}],
	"technologies":[],
	"illustration":"",
	"architecture":"The object model is re-using basic Java implementation.",
	"usage":"* The implementation is provided as an Eclipse project. \n* To run this service locally you need a JBoss v.5.0 installed"
},
{
	"name":"jaxbChoice",
	"summary":"[[O\/X mapping]] with [[Technology:JAXB]]",
	"motivation":"See [[101implementation:jaxbComposition]] for the overall motivation of exercising \n[[Technology:JAXB]] and arguably a simple baseline for a schema and the \ncorresponding schema-derived classes. The present implementation exercises\nan XSD choice for different kinds of subunits. The schema-derived class\nSubunit encodes the choice in an arguably sub-optimal manner (as a result\nof the lack of a good match for XSD choices in the Java type system).\nOne could expect that XSD choices (of a restricted kind) could be \ntranslated into class inheritance, but this does not happen here (and\nthis may be understandable).",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XSD"},
		{"name":"Java"}],
	"technologies":[{"name":"JAXB"},
		{"name":"xjc"}],
	"architecture":"See [[101implementation:jaxbComposition]].",
	"usage":"See [[101implementation:jaxbComposition]]."
},
{
	"name":"jaxbComposition",
	"summary":"[[O\/X mapping]] with [[Technology:JAXB]]",
	"motivation":"O\/X mapping within the Java platform is exercised.\nThe primary data model for companies is an XML schema. The schema compiler\n[[Technology:xjc]] of [[Technology:JAXB]] is used to generate Java classes\nfrom the schema. In this manner, operations on an XML representation of\ncompanies can be implemented in near-to-regular OO fashion while\nusing a problem-specific object model. \nIn different terms, one can carry out [[:Category:XML processing]] while\nessentially staying in the technical space of [[objectware]]. It is insightful\nto compare XML schema and schema-derived classes. The XML\nschema is defined in a manner that the resulting object model systematically\nleverages [[object composition]] and no [[class inheritance]]. In fact, the\nschema-derived classes are very similar to a regular OO design; see \n[[101implementation:javaComposition]]. It is important to note that \nthe operations on companies are not implemented as [[:Category:instance method]]s\nsince this would imply modification of schema-derived classes---unless advanced \nmodularization mechanisms were leveraged. Instead, the operations are implemented\nas [[:Category:static method]]s in non-schema-derived classes.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XSD"},
		{"name":"Java"}],
	"technologies":[{"name":"JAXB"},
		{"name":"xjc"}],
	"illustration":"The following XML schema fragment shows the element declaration for departments:\n\n<syntaxhighlight lang=\"xml\">\n <xs:element name=\"department\">\n  <xs:complexType>\n   <xs:sequence>\n    <xs:element ref=\"name\"\/>\n    <xs:element name=\"manager\" type=\"employee\"\/>\n    <xs:element ref=\"department\"\n                maxOccurs=\"unbounded\" minOccurs=\"0\"\/>\n    <xs:element name=\"employee\" type=\"employee\"\n                maxOccurs=\"unbounded\" minOccurs=\"0\"\/>\n   <\/xs:sequence>\n  <\/xs:complexType>\n <\/xs:element>\t\n<\/syntaxhighlight>\nThat is, department elements line up children elements for name, manager, sub-departments,\nand employees. There is an XSD type ''employee'' which is used in two local element\ndeclarations: one for managers; another one for regular employees. The\nschema-derived class for departments looks as follows:\n\n<syntaxhighlight lang=\"java\">\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"\", propOrder = {\n    \"name\",\n    \"manager\",\n    \"department\",\n    \"employee\"\n})\n@XmlRootElement(name = \"department\")\npublic class Department {\n    @XmlElement(required = true)\n    protected String name;\n    @XmlElement(required = true)\n    protected Employee manager;\n    protected List<Department> department;\n    protected List<Employee> employee;\n    \/\/ Getters and setters omitted\n}\n<\/syntaxhighlight>\nThis class essentially models [[POJO]]s for departments in a way similar to\nregular OO programming. However, the schema compiler injects a number of [[:Category:annotation]]s \ninto the schema-derived classes so that sufficient information is tracked for serialization,\nand, in fact, [[validation]]. For instance, the fields for name and manager are annotated with \n''required=true'', thereby expressing that a valid department object must specify a name\nand manager. On top of the schema-derived classes, the operation ''cut'' is implemented\nwith [[:Category:static method]]s: \n\n<syntaxhighlight lang=\"java\">\npublic class Cut {\n  public static void cut(Company c) {\n    for (Department d : c.getDepartment())\n      cut(d);\n  }\n  public static void cut(Department d) {\n    cut(d.getManager());\n    for (Department s : d.getDepartment())\n      cut(s);\n    for (Employee e : d.getEmployee())\n      cut(e);\n  }\n  public static void cut(Employee e) {\n    e.setSalary(e.getSalary() \/ 2);\n  }\t\t\n}\n<\/syntaxhighlight>",
	"architecture":"''Company.xsd'' is the schema for [[schema-first mapping]].\n''Makefile'' shows how to (trivially) invoke the schema compiler [[Technology:xjc]] \nof [[Technology:JAXB]]. Package ''org.softlang.company'' hosts all schema-derived\nclasses and interfaces. Package ''org.softlang.features'' hosts \nimplementations for [[101feature:Total]] and [[101feature:Cut]] as well as\nsome boilerplate code for [[101feature:Serialization]]. Package ''org.softlang.tests''\nhosts JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in package ''org.softlang.tests''.\n* If you want to regenerate classes from the scheme, see the ''Makefile''.\n\nHint: if you need to add schema files to a project so that XML files are \nautomatically validated on the grounds of their namespace, as it is useful for\nthe schema Company.xsd, which is part of the present implementation, then \nyou need to add the files via Eclipse preferences -> XML -> XML catalog."
},
{
	"name":"jaxbExtension",
	"summary":"[[O\/X mapping]] with [[Technology:JAXB]]",
	"motivation":"See [[101implementation:jaxbComposition]] for the overall motivation of exercising \n[[Technology:JAXB]] and for arguably a simple baseline of a schema and \ncorresponding schema-derived classes. The present implementation \nrepresents an attempt to model different kinds of subunits of department \n(i.e., sub-departments and employees) as subtypes of a common supertype \nof subunits, where subtyping is meant here in the sense of XSD's type \nextension mechanism. The result is rather complex at both ends.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XSD"},
		{"name":"Java"}],
	"technologies":[{"name":"JAXB"},
		{"name":"xjc"}],
	"architecture":"See [[101implementation:jaxbComposition]].",
	"usage":"See [[101implementation:jaxbComposition]]."
},
{
	"name":"jaxbSubstitution",
	"summary":"[[O\/X mapping]] with [[Technology:JAXB]]",
	"motivation":"See [[101implementation:jaxbComposition]] for the overall motivation of exercising \n[[Technology:JAXB]] and for arguably a simple baseline of a schema and \ncorresponding schema-derived classes. The present implementation \nrepresents an attempt to model different kinds of subunits of department \n(i.e., sub-departments and employees) as subtypes of a common supertype \nof subunits, where subtyping is meant here in the sense of XSD's substitution\ngrouping mechanism. The result is rather complex at both ends.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XSD"},
		{"name":"Java"}],
	"technologies":[{"name":"JAXB"},
		{"name":"xjc"}],
	"architecture":"See [[101implementation:jaxbComposition]].",
	"usage":"See [[101implementation:jaxbComposition]]."
},
{
	"name":"jdbc",
	"summary":"Database programming with [[Technology:JDBC]]",
	"motivation":"",
	"features":[],
	"languages":[{"name":"SQL"},
		{"name":"Java"}],
	"technologies":[{"name":"JDBC"},
		{"name":"MySQL"}],
	"usage":"* You need a suitable JDBC Driver for MySQL\n** An appropriate driver is available here: http:\/\/dev.mysql.com\/downloads\/connector\/j\/\n** Some version of that driver is readily included into the project.\n* Set up a company database.\n** Follow the steps described here [[101implementation:mySql]] to set up the company database. That is, stop after populating the tables. \n* There are JUnit tests available as the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features."
},
{
	"name":"jdbc2",
	"summary":"Database programming with [[Technology:JDBC]]",
	"motivation":"",
	"features":[],
	"languages":[{"name":"SQL"},
		{"name":"Java"}],
	"technologies":[{"name":"JDBC"},
		{"name":"MySQL"}],
	"architecture":"The package ''org.softlang.company'' contains the object model.\nThe ''ObjectFactory'' in ''org.softlang.util'' is used to retrieve objects from the database.\nThe PersistenceTool writes objects back to the database.\nSome minimal effort is made to only commit *changes* to the database.\nThe tests package ''org.softlang.tests'' contains test cases.\n\nPrerequisites (very much like in project \"jdbc\"):",
	"usage":"* You will need a suitable JDBC Driver for MySQL\n**  An appropriate driver is available here: http:\/\/dev.mysql.com\/downloads\/connector\/j\/\n**  Add the JAR that comes with the download to the build path of this project.\n* Set up a company database.\n** Follow the steps described here [[101implementation:mySql]] to set up the company database. That is, stop after populating the tables. \n* There are JUnit tests available as the package ''org.softlang.tests''.\n** Run class ''Basics'' with JUnit to exercise basic features.\n** Run class ''Persistence'' with JUnit to exercise O\/R mapping \/ persistence.",
	"issues":"* Overall, the idea of loading employees one by one may be ill-conceived.\n* Lazy load is triggered upon testing collection items for changes; see Department.isChanged.\n* The load method should not be in the iterator for collections but in the getters (and some of the setters) for items in the collection.\n* Persist methods seem to drill down to leafs even beyond what had been loaded (and could be changed).\n* Clear methods should use information about what has been *added* or *removed*.\n* The id after insertion should be determined in a more robust manner.\n\nCosmetics:\n* Rename ObjectFactory to Loader?\n* Rename PersistenceTool to Saver?\n* Use shorter names pstmt -> stm for example.\n* Use overloading rather than long names such as persistDepartment."
},
{
	"name":"jdom",
	"summary":"exercise [[in-memory XML processing]] with [[Technology:JDOM]] in [[Language:Java]]",
	"motivation":"See [[101implementation:dom]] for a general motivation for exercising\n[[in-memory XML processing]]. The present implementation simply exercises\nyet another DOM-like API.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"XML"},
		{"name":"Java"}],
	"technologies":[{"name":"JDOM"}],
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available though class ''org.softlang.jdom.Tests''."
},
{
	"name":"jena",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"jena2",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"jgralab",
	"summary":"use [[Language:TGraphs]] with [[Technology:JGraLab]] in [[Language:Java]]",
	"motivation":"TGraphs are typed, attributed, ordered, and directed graphs.\nTGraphs can be maintained in a repository and programmatically processed.\nOne can clearly use TGraphs to represent companies.\nIn fact, a TGraphs schema defines the structure of companies.\nOne can then use supplementary languages and technologies to query and transform such graphs \nso that typical operations on companies are implemented.\nIn particular, [[Technology:JGraLab]] supports Java-class generation from a TGraphs schema,\nand query evaluation with [[Language:GReQL]] on TGraphs.\nTransformations can be performed with [[Language:GReTL]]\nor ''plain'' Java based on the schema-derived API.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"mentoring"},
		{"name":"serialization"},
		{"name":"visualization"}],
	"languages":[{"name":"TGraphs"},
		{"name":"GReQL"},
		{"name":"GReTL"},
		{"name":"Java"}],
	"technologies":[{"name":"JGraLab"},
		{"name":"GReTL"},
		{"name":"GraphViz"}],
	"architecture":"The file ''101companies-schema.xmi'' is the schema TGraph that represents the data\nstructure for companies. This file was exported from the\nIBM Rational Software Architect (RSA) tool and is based on a simple UML class diagram.\nThe file ''101companies-schema.pdf'' illustrates the UML class diagram that was\nmodeled to represent the schema. The file ''101companies-schema.emx'' is the original IBM RSA model file.\nOnce generated, the file ''101companies-schema.tg''\n\nThe jgralab.jar contains the core technology for creating and operating on TGraphs.\nIt also contains the facilities for using GReQL. The gretl.jar contains GReTL for modifying TGraphs.\n\nPackage ''src.de.uni_koblenz.oneoonecompanies'' contains a programmer-defined\nclass ''CompanyServices'' that provides an API for several operations on TGraphs. \nPackages ''src.de.uni_koblenz.oneoonecompanies.schema'' and ''...schema.impl.std''\ncontain schema-derived interfaces and classes for companies.",
	"usage":"* The implementation is provided as an Eclipse project.\n* Run ''build.xml'' with ant to generate schema-derived classes and interfaces. \n* There are tests in package ''...tests''.\n** Run JUnit test ''Serialization'' to exercise the serialization capability.\n** Run JUnit test ''Operations'' to exercise the basic operations.\n** Run main method of ''Visualization'' to exercise the visualization capability.\n\nPlease note: Upon initial checkout and whenever the TGraphs schema ''101companies-schema.xmi''\nis changed, then code generation must be re-executed. To this end, run ''ant'' on the included \n''build.xml'' file from the command line or from within Eclipse. This process re-generates \nall types in the packages ''...schema'' and ''...schema.impl.std''.  These packages provide\nthe API for ''CompanyServices''."
},
{
	"name":"jocamlJoinPatterns",
	"summary":"A [[Language:JoCaml|JoCaml]]-based implementation that uses [[join patterns]]",
	"motivation":"Nowadays, [[event handling]] is a standard technique in GUI programming. However, \nthere is a lot of research going on to use such an [[event handling|event-based]] \napproach for [[concurrency|concurrent programming]]. The idea is to [[101feature:Parallelism|parallelize]] \nthe [[event handling|handling of events]] by combining simple [[events]] to \nmore complex ones using so called [[join patterns]]. This project demonstrates \nthe usage of [[concurrency]] by [[event handling]] in JoCaml using such \n[[join patterns]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parallelism"}],
	"languages":[{"name":"JoCaml"}],
	"technologies":[{"name":"jocaml"},
		{"name":"jocamlc"},
		{"name":"GNU make"},
		{"name":"diff"}],
	"illustration":"[[Join patterns]] combine several [[events|event]] [[channels]], which all must be \nserved in order to start the [[event handling|handling]]. If [[channels]]\nrepresent functions on an object-like strucure another [[channels|channel]] is often used\nas a internal [[state]], which is modified by the function.  \n\n <nowiki>\n(* join pattern for cut *) \ndef employeeState (n, a, s) & cut () = \n    employeeState (n, a, s *. 0.5)\n<\/nowiki>\n\nFor example the internal state ''employeeState (n, a, s)'' describes an employee \nwith name, address and salary. If a [[101feature:Cut|Cut]]-[[Events|event]] \noccurs this internal [[state]] is consumed and triggered again with a modified \nsalary.",
	"architecture":"* ''company.ml'' company structure\n* ''company.mli'' header, company signature\n* ''meganalysis.ml'' sample company\n* ''main.ml'' simple test program",
	"usage":"You need to install J[[Language:JoCaml|JoCaml]] . \n\nUse the [[Technology:GNU make|makefile]] for some demo:\n* Enter ''make compile'' to compile the code\n* Enter ''make test'' to execute the script contained in ''main.ml'' and to perform a simple [[Technology:diff|diff-based]] test"
},
{
	"name":"jsf",
	"summary":"[[web programming]] with [[Technology:JavaServer Faces]]",
	"motivation":"This implementation covers the popular approach for [[web programming]] with [[Technology:JavaServer Faces]]. It introduces the [[Technology:GlassFish]] [[:Category:Application server]]. The implementation illustrates the use of the [[Model View Controller|MVC]]- and [[Data Access Object|DAO]]-[[:Category:Pattern|patterns]]. The model, view and controller are implemented with [[Technology:JavaServer Faces]], where the database connection is implemented with [[Technology:Hibernate]].",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"persistence"},
		{"name":"precedence"},
		{"name":"validation"}],
	"languages":[{"name":"Java"},
		{"name":"XHTML"},
		{"name":"CSS"},
		{"name":"XML"}],
	"technologies":[{"name":"JavaServer Faces"},
		{"name":"Hibernate"},
		{"name":"NetBeans"},
		{"name":"GlassFish"}],
	"illustration":"The features [[101feature:Cut]] and [[101feature:Total]] are implemented by [[Technology:Java Beans]]. In case of [[101feature:Company|company]] the [this!!jsf\/web\/company.xhtml company.xhtml] contains a button:\n\n<syntaxhighlight lang=\"xml\" source=\"jsf\/jsf\/web\/company.xhtml\" line>\n<h:commandButton value=\"cut\"\n    actionListener=\"#{companyBean.cut()}\"\/>\n<\/syntaxhighlight>\nThe commandButton creates an html-button with the name \"cut\", specified by the attribute value. The action-listener invokes the method cut() in the managed [[Technology:Java Beans|bean]] [this!!jsf\/src\/java\/company\/beans\/jsf\/CompanyBean.java CompanyBean.java]:\n\n<syntaxhighlight lang=\"java\" source=\"jsf\/jsf\/src\/java\/company\/beans\/jsf\/CompanyBean.java\" line>\n\/\/ this method cuts all employees of the loaded company\npublic void cut() {\n    HibernateUtil.getSessionFactory()\n        .getCurrentSession().beginTransaction();\n    DAOFactory daoFactory = DAOFactory\n        .instance(DAOFactory.HIBERNATE);\n    EmployeeDAO employeeDAO = daoFactory\n        .getEmployeeDAO();\n\n    for (Employee employee : employees) {\n        employee.setSalary(employee.getSalary() \/ 2);\n        employeeDAO.makePersistent(employee);\n    }\n    \n    total = total \/ 2;\n    HibernateUtil.getSessionFactory()\n        .getCurrentSession().getTransaction().commit();\n}\n<\/syntaxhighlight>",
	"architecture":"* The architecture is based on the [[Model View Controller|MVC]]-[[:Category:Pattern|pattern]]. View and Controller are implemented with the [[Technology:JavaServer Faces|JSF]]-technology. The view is made with [[Technology:Facelets]], e. g. [this!!jsf\/web\/company.xhtml company.xhtml], [this!!jsf\/web\/department.xhtml department.xhtml], [this!!jsf\/web\/employee.xhtml employee.xhtml]. The model is made with [[Technology:Java Beans#Managed Beans|managed beans]]. The view connects to the specific methods of this models[this!!jsf\/src\/java\/company\/beans\/jsf\/CompanyBean.java CompanyBean.java], [this!!jsf\/src\/java\/company\/beans\/jsf\/DepartmentBean.java DepartmentBean.java] and [this!!jsf\/src\/java\/company\/beans\/jsf\/EmployeeBean.java EmployeeBean.java] by invoking the controller (Faces servlet).\n\n* The [[Technology:JavaServer Faces|JSF]]-framework creates [[Language:HTML]]- and [[Language:JavaScript]]-code out of the [[Technology:Facelets]]. Within this [[Language:JavaScript]], the [[:Category:Client]] creates requests to the [[:Category:Server]] via [[Technology:XMLHttpRequest]].\n\n* The [[Technology:Java Beans]] encapsulate business methods to create the webservices, which send the responses to the [[:Category:Client]]-requests. The used [[:Category:Webserver]] for this webservices is [[Technology:GlassFish]].\n\n* The grid for the main [[101feature:Interaction|GUI]] features is implemented via [this!!jsf\/web\/template.xhtml template]. This template adjusts the headline, content-frame and button-line for each view.\n\n* The database connection is realized as [[Data Access Object|DAOs]]. The [[Technology:Java Beans]] call the DAO-methods and the DAOs fill the [this!!jsf\/src\/java\/company\/classes\/company.java company]-, [this!!jsf\/src\/java\/company\/classes\/department.java department]- and [this!!jsf\/src\/java\/company\/classes\/employee.java employee]-objects. In case of this implementation, the DAO connects to a [[Technology:MySQL]]-Database via [[Technology:Hibernate]].",
	"usage":"You need an sql-server to use this application. In this tutorial both will be taken by XAMPP: http:\/\/www.apachefriends.org\/en\/xampp.html\n\nYou can use the ''company.sql'' and ''sampleCompany.sql'' of [[101implementation:mySql]] for this project.\n\n* Download and install XAMPP\n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"MySQL\"\n* Use the guideline of [[101implementation:mySql]] up to \"Populate tables...\"\n\nAfter the database is running, follow the next steps:\n\n* To start the application, you need to download all project-files except the README\n* Open the project with [[Technology:NetBeans]] (http:\/\/netbeans.org\/)\n* Select the project, right click and ''run''\n* The glassfish-server (and a browser window) with the application will start automatically\n\nThe project is implemented with [[Technology:NetBeans]] 7.0.1. You will need the full version with an installed [[Technology:GlassFish]] [[:Category:Webserver]]."
},
{
	"name":"kiama",
	"summary":"demonstrate Kiama",
	"motivation":"Kiama provides several advanced programming concepts:\ncontext-sensitive attribute equations, circular attribute equations,\nrewrite rules and higher-order rewriting strategies.  The present\nimplementation puts to work some of them for the benefit of a\ndeclarative and concise implementation of the 101companies system.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"precedence"}],
	"languages":[{"name":"Scala"}],
	"technologies":[{"name":"Kiama"}],
	"usage":"Use the simple-build-tool to build: sbt script for Unix and MacOSX and\nsbt.bat script for Windows.\n\n(One time only) Download Scala compiler and needed libraries:\n\n<pre>\n$ .\/sbt update\n<\/pre>\n\nThis downloads and installs the relevant jars in your project, so you\nneed to be on the net for it to work. \n\nThe remaining steps can be performed without a net connection.\n\nTo compile the project (if necessary) and run the main program:\n\n<pre>\n$ .\/sbt run\n399747.0\n199873.5\n3\n<\/pre>\n\nTo run the tests with logging:\n\n<pre>\n$ .\/sbt info test\n<\/pre>"
},
{
	"name":"linq2DataSet",
	"summary":"an implementation with O\/R mapping using LINQ2DataSet",
	"motivation":"",
	"features":[],
	"languages":[{"name":"CSharp"}],
	"technologies":[],
	"architecture":"",
	"usage":""
},
{
	"name":"linq2Sql",
	"summary":"a basic implementation for O\/R mapping using LINQ2SQL",
	"motivation":"",
	"features":[],
	"languages":[{"name":"CSharp"}],
	"technologies":[],
	"architecture":"",
	"usage":""
},
{
	"name":"mobl",
	"summary":"Implementation of 101 companies in mobl (http:\/\/mobl-lang.org). ",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"moose",
	"summary":"an implementation in a Pharo Smalltalk with the Moose capabilities.",
	"motivation":"",
	"features":[],
	"languages":[{"name":"Smalltalk"}],
	"technologies":[{"name":"Pharo"}],
	"usage":"1. Download and open Moose:\nhttp:\/\/moosetechnology.org\/download\n\n2. Drag and drop load-101companies.st into Moose\n\n3. Choose FileIn"
},
{
	"name":"mps",
	"summary":"an implementation based on [[Technology:MPS]]",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"mySql",
	"summary":"Database and SQL-based approach with [[Technology:MySQL]]",
	"motivation":"",
	"features":[],
	"languages":[{"name":"SQL"}],
	"technologies":[{"name":"MySQL"},
		{"name":"XAMPP"},
		{"name":"MySQL Workbench"}],
	"usage":"We use SQL for data processing.\nWe exercise some company scenarios.\nThis project is entirely SQL\/scripting-based.\n\nWe need a local database Server.\nIn the following we explain the steps for XAMPP.  \nhttp:\/\/www.apachefriends.org\/en\/xampp.html\n\nWe also need some SQL tool.\nIn the following we explain the steps for MySQL Workbench.\nhttp:\/\/dev.mysql.com\/downloads\/workbench\/\n\n* Download and install XAMPP. \n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"Mysql\".\n* A local MySQL Server is now running:\n Server Host : \"localhost\"\n Port : 3306\n Username : \"root\"\n Password : \"\" (no password)\n* Connect to database in MySQL Workbench.\n* Select \"test\" schema or create one.\n* Create tables (run SQL script Company.sql)\n* Populate tables (run SQL script sampleCompany.sql)\n* Execute scenario total (run SQL script Total.sql)\n* Execute scenario cut (run SQL script Cut.sql)\n* Execute scenario total, again (run SQL script Total.sql)"
},
{
	"name":"prolog",
	"summary":"Logic programming-based implementation",
	"motivation":"We implement some \"company\" scenarios in Prolog.\nThere is a predicate total\/2 to total all salaries in a company.\nThere is a predicate cut\/2 to cut all salaries in half.\nThere is a predicate depth\/2 to compute the nesting depth of departments.\nSee the Makefile for running the tests.\nThe code has been tested with SWI-Prolog 5.10.1.",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"prologSyb",
	"summary":"Prolog-based implementation with SYB support",
	"motivation":"TBD",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"py3k",
	"summary":"a basic implementation of the spec in Python 3",
	"motivation":"Python is a dynamically typed scripting language, mainly focussed on OO-programming but nonetheless offering some tools to also provide basic functional programming capabilities. Python also prides itself on it's \"Batteries included\" philosophy which means that the language's standard library shouldcover all possible basic use cases of the language. This implementation takes the basic OO approach, implementing Company, Dept and Employee as classes, though due to python's dynamic approach, no inheritance hierarchy is needed (we could do this using dictionaries and classes in fact aren't that much more).\nUsing Python's Pickle serialization module, the whole model can be serialized without further adaptation.\nThe model implements structural equality, but only for the purpose of unit testing serialization.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Python 3.2"}],
	"technologies":[{"name":"Py3k"}],
	"architecture":"All classes and methods are contained in ''Company.py''. Tests are in ''CompanyTest.py''.\nThe [[101feature:Serialization]] is achieved using the pickle module.",
	"usage":"Make sure to grab Python 3 from python.org, then from the project directory execute\n\n <nowiki>python3 CompanyTest.py -v<\/nowiki>\n\nto run the test cases"
},
{
	"name":"qt",
	"summary":"[[101feature:Interaction|GUI]]-Programming with [[Language:C++]] and [[Technology:QT]]",
	"motivation":"''This project was created at the PTT-Hackathon 2011''",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"}],
	"languages":[{"name":"C++"}],
	"technologies":[{"name":"QT"},
		{"name":"QTCreator"}],
	"illustration":"",
	"architecture":"",
	"usage":""
},
{
	"name":"ruby",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"sax",
	"summary":"exercise [[push-based XML parsing]] with [[Technology:SAX]] in [[Language:Java]]",
	"motivation":"[[:Category:XML processing]]",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"XML"},
		{"name":"XSD"},
		{"name":"Java"}],
	"technologies":[{"name":"SAX"},
		{"name":"XMLStreamWriter"},
		{"name":"JAXP"}],
	"architecture":"Package ''org.softlang.operations'' hosts implementations of the operations\n[[101feature:Total]] and [[101feature:Cut]]. These operations are implemented\nby SAX handlers; output XML is written with XMLStreamWriter. [[101feature:Company]] \nis implemented by the XML schema Company.xsd. The schema is not needed for the \nbasic operations, but one can perform XML validation with regard to the schema; \nsee the JUnit tests. Package ''org.softlang.sax'' hosts some boilerplate code\nfor SAX: it covers basic functionality for parsing, tracing, and validation.\nPackage ''org.softlang.tests'' hosts various JUnit tests; see below.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations.\n** Run class ''Trace'' with JUnit to see the trace of parsing a file with SAX.\n** Run class ''Validate'' with JUnit to validate all XML files against the schema for companies."
},
{
	"name":"scala",
	"summary":"a very very OO implementation of the basic spec in Scala",
	"motivation":"This defines a minimal approach to realize the basic spec using Scala's OO features. In Scala terms this could be considered a ''Java without semicolons'' implementation.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"Scala 2.8.1"}],
	"technologies":[{"name":"Scala"},
		{"name":"sbt"},
		{"name":"sbt-idea"},
		{"name":"ScalaTest"}],
	"architecture":"The implementation features fully mutable classes and total and cut are implemented as instance methods. The implementation contains three files:\n\n* ''Company.scala'' contains everything related to the Company entity\n* ''Employee.scala'' contains classes describing the company personnel\n* ''Dept.scala'' contains the implementation of Departments",
	"usage":"You need to install sbt to build and run this project as shown on the sbt [http:\/\/code.google.com\/p\/simple-build-tool\/wiki\/Setup website]. Then change into the base directory of the project and run\n <nowiki>sbt update<\/nowiki>\nThis should fetch all needed dependencies. After that you can compile the project by typing\n <nowiki>sbt compile<\/nowiki>\nand then\n <nowiki>sbt test<\/nowiki>\nto run the tests."
},
{
	"name":"scala2",
	"summary":"an implementation of the basic spec in [[Language:Scala]] providing typeclass based serialization using SJSON",
	"motivation":"This implementation utilizes a more idiomatic, functional style approach than [[implementation:scala]]. The model is realized using only immutable data structures and the total and cut computation are realized by recursively mapping over the elements of the Department tree.\nBecause the model is immutable, it is easily serialized. In addition, an example of JSON serialization was implemented using the sjson Library by Debasish Ghosh. Serialization patterns for all types of the Company domain are realized by implementing typeclass for each one.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Scala"}],
	"technologies":[{"name":"Scala"},
		{"name":"sbt"},
		{"name":"sjson"},
		{"name":"ScalaTest"}],
	"architecture":"The implementation is straightforward. All of the basic features are contained in ''Company.scala'' and [[101feature:Serialization]] is found in ''JSONSerialization.scala''. Basic test cases are provided.",
	"usage":"You need to install sbt to build and run this project as shown on the sbt [http:\/\/code.google.com\/p\/simple-build-tool\/wiki\/Setup website]. Then change into the base directory of the project and run\n <nowiki>sbt update<\/nowiki>\nThis should fetch all needed dependencies. After that you can compile the project by typing\n <nowiki>sbt compile<\/nowiki>\nand then\n <nowiki>sbt test<\/nowiki>\nto run the tests."
},
{
	"name":"scalaAkkaActors",
	"summary":"This is an implementation of the basic spec using [[Language:Scala]] together with the [[Technology:Akka]] toolkit's actor library as well as Akka's Typed Actors.",
	"motivation":"This implementation uses Akka to show how a strong, static type system can serve to type check the inherently dynamic actor pattern by encapsulating actors behind typesafe proxy interfaces.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"parallelism"}],
	"languages":[],
	"technologies":[{"name":"Scala"},
		{"name":"Akka"},
		{"name":"sbt"},
		{"name":"specs2"}],
	"architecture":"In ''Company.scala'' a regular Akka actor-based implementation is given as a reference. ''TypedCompany.scala'' shows how the message passing is hidden behind traits that provide a front from which Akka can construct a proxy object to interact with.",
	"usage":"This implementation uses sbt 0.10 as build tool, available at [http:\/\/github.com\/harrah\/xsbt\/]. After installing sbt just change into the project directory and run\n <nowiki>sbt<\/nowiki>\nto create the project, followed by\n <nowiki>sbt update<\/nowiki>\nThis should fetch any needed dependencies. After that you can compile the project by typing\n <nowiki>sbt compile<\/nowiki>\nand then\n <nowiki>sbt test<\/nowiki>\nto run the tests.",
	"issues":"Akka is currently transitioning to version 2.0 which radically changes and simplifies the implementation of TypedActors. Upon release of Akka 2.0, a revision of this implementation is to be scheduled."
},
{
	"name":"scalaXML",
	"summary":"an implementation of the basic spec in [[Language:Scala]] utilizing Scala's builtin XML handling features.",
	"motivation":"This implementation shows the use of XML literals which are built into Scala at language level. At no point, an object model is generated beyond Scala's internal XML representation.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Scala"}],
	"technologies":[{"name":"Scala"},
		{"name":"sbt"},
		{"name":"Specs"}],
	"architecture":"All relevant code is contained in ''CompanyXMLReader.scala''. The cut and total capabilities are contained in a singleton object by the same name. In ''Validator.scala'', a default XML Schema validator is provided for testing purposes.",
	"usage":"This implementation uses sbt 0.10 as build tool, available at [http:\/\/github.com\/harrah\/xsbt\/]. After installing sbt just change into the project directory and run\n <nowiki>sbt<\/nowiki>\nto create the project, followed by\n <nowiki>sbt update<\/nowiki>\nThis should fetch any needed dependencies. After that you can compile the project by typing\n <nowiki>sbt compile<\/nowiki>\nand then\n <nowiki>sbt test<\/nowiki>\nto run the tests."
},
{
	"name":"seam",
	"summary":"illustrate building a web applications with Seam",
	"motivation":"This is a simple web implementation of the basic 101companies-features, plus \ndatabase persistence and authentication\/authorization feaures, using  \nthe SEAM framework.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"persistence"},
		{"name":"access control"}],
	"languages":[{"name":"Java"},
		{"name":"HQL"},
		{"name":"XHTML"}],
	"technologies":[{"name":"Seam"}],
	"illustration":"",
	"architecture":"",
	"usage":"* '''Requirements:'''\n** [[Technology:JBoss Application Server]] Version 4.2.x (http:\/\/sourceforge.net\/projects\/jboss\/files\/JBoss\/JBoss-4.2.3.GA)\n** [[Technology:Eclipse]]\n* '''Import:'''\n** Import the seam project as a java project into eclipse.\n** change the build.properties located in the projects base folder. The ''jboss.home''-property must refer to your JBoss location:\n jboss.home = <your jboss location>\n* '''Build:'''\n** run the seam project as ant build in eclipse.\n* '''Run:'''\n** Run jboss using ''<your jboss location>\/bin\/run.bat''\n* '''Access:'''\n** start a web-browser\n** go to: http:\/\/localhost:8080\/seam\n** Access the system with user ''admin'' (pw:''admin''). You can also access the system with user ''user'' (pw: ''user'') but then the cut salaries method is blocked.\n\n[[Category:Web application]]"
},
{
	"name":"seaside",
	"summary":"",
	"motivation":"a web-based implementation in [[Language:Smalltalk]]",
	"features":[{"name":"company"},
		{"name":"cut"},
		{"name":"total"}],
	"languages":[{"name":"Smalltalk"}],
	"technologies":[{"name":"Pharo"},
		{"name":"Seaside"}],
	"illustration":"There is a basic OO implemenetation.\n\nCut for the Employee\n<syntaxhighlight lang=\"smalltalk\">\ncut\n\tsalary := salary \/ 2\n<\/syntaxhighlight>\nTotal for the Employee\n<syntaxhighlight>\ntotal\n\t^salary\n<\/syntaxhighlight>\nCut for the Departmnent\n\n<syntaxhighlight lang=\"smalltalk\">\ncut\n\tsuper cut.\n\tmanager cut.\n\temployees do:[:each | each cut]\n<\/syntaxhighlight>\nTotal for the Department\n\n<syntaxhighlight lang=\"smalltalk\">\ntotal\n\t^self employees inject:((manager total) + (super total)) into:[:total :current | total + current total]\n<\/syntaxhighlight>\n\nThe second part contains a layer of web-specific components.",
	"architecture":"",
	"usage":"* 1. Download Seaside for Pharo (http:\/\/www.seaside.st\/download\/pharo).\n* 2. Open Seaside environment.\n* 3. Open \"world\" context menu within seaside (right click or double left click). Tools->File Browser. Navigate to the \"implementations\\seaside\" folder in your svn repository.  \n* 4. Select ''101companies.st'' and click \"install\" on a toolbar.\n* 5. Select ''101companies-Tests.st'' and click \"install\" on a toolbar.\n\nAt this point you should be able to see 101comanies and 101companiesTests in the components browser.\nNext you have to start a web-server. For this go to the \"Seasise Control Panel\", select [8080]WAComancheAdaptor and click \"Start\" button.\n\nIf you don't see any adapters:\n* 1. Open the \u2019Seaside Control Panel\u2019 in the \u2019Tools\u2019 submenu of the \u2019World\u2019 menu\n* 2. Should there be no WAComancheAdaptor add one by right clicking and selecting \u2019Add adaptor...\u2019\n* 3. Select the WAComancheAdaptor and press \u2019Start\u2019.\n\nOpen http:\/\/localhost:8080\/101companies in your web-browser.\n\n[[Category:Web application]]"
},
{
	"name":"silverlight",
	"summary":"Web-based UI implemented in [[Technology:Silverlight]]",
	"motivation":"* Implementation runs in a web browser\n* Asynchronous WCF service calls are used to communicate with a server\n* Back button is supported out-of-the box\n* Navigation framework is used to implement MVC",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"Silverlight"}],
	"illustration":"",
	"architecture":"[http:\/\/msdn.microsoft.com\/en-us\/library\/cc838245(v=vs.95).aspx#application_navigation] for Navigation",
	"usage":"[[Category:Web application]]"
},
{
	"name":"sqlServer",
	"summary":"an implementation in a relational database using [[Technology:SQL Server]]",
	"motivation":"Please note: ''This implementation is prerequisite for\n[[101implementation:ef]].'' A simple relational schema is used to\nmodel the data part of the [[101companies:System]]. In particular,\nthere are tables for companies, departments, employees (and\npersons). Further, there are primary and foreign keys that represent\ndifferent types of relationships. For instance, departments associate\nthemselves with a company by a foreign key. The SQL-based\nimplementation also includes triggers--to represent\nconstrains\/cardinality. Finally, there are SQL scripts covering the\noperations for totaling and cutting salaries.  An implementation of\nthe query for the depth of departmental nesting is available as well,\nbut it is strikingly complex because of SQL's known issues with\nrecursion.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"persistence"}],
	"languages":[{"name":"SQL"}],
	"technologies":[{"name":"SQL Server"},
		{"name":"Visual Studio"}],
	"architecture":"The following artifacts are used to create relational model for\n101companies:\n\n* Tables (TableName.table.sql)\n* Primary keys (Name.pkey.sql)\n* Foreign keys (Name.fkey.sql)\n* Triggers (Name.trigger.sql)\n\nThe scripts\/Post-Deployment folder contains script file executed after\nthe database schema was created to fill in the database with actual\n101companies data.",
	"usage":"[[Technology:Visual Studio]] 2010 should be used to open a project\nfile. The deploy option should be used to create the database. The\ntarget connection (in project properties) should be adjusted for the\nlocal database server."
},
{
	"name":"stratego",
	"summary":"",
	"motivation":"",
	"features":[],
	"languages":[],
	"technologies":[]
},
{
	"name":"strutsAnnotation",
	"summary":"implement a web application with Struts, but the redirections ",
	"motivation":"This is a simple web implementation of the basic 101companies-features using  \nStruts2 (annotations) and Serialization as persistence mechanism. \nIt provides server-side storage for the data using serialization.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"},
		{"name":"JavaServerPages"}],
	"technologies":[],
	"illustration":"The company data is stored in a serialization file. To obtain the stored data, we implemented \na few services (methods) in the CompanyService class, which is a singleton.\n\n<syntaxhighlight lang=\"java\">\npublic class CompanySerivce { \n ...\n private static CompanyService instance;\n \n public static CompanyService instance() {\n   if(instance == null) {\n     instance = new CompanyService();\n   }\n   return instance;\n }\n\t\n public List<Company> listAllCompanies() {\n   if(companies == null || companies.size() == 0) {\n     companies = new ArrayList<Company>();\n\t Company company = Company.readObject(\"sampleCompany.ser\");\n\t companies.add(company);\n\t}\n\treturn companies;\n }\n ...\n}\n<\/syntaxhighlight>\nServices in this class implement access methods to the company data. \n\nBased on the struts2 architecture, the controller layer is implemented \nby Java classes (action classes) with special annotations; whereas the view layer might be implemented using \nJava Server Pages (JSPs) or other template languages such as Velocity. Here, \nwe use JSPs to implement the view layer. For instance, consider an action class \nthat deals with all requests related to departments (requests such as detailing departments \nor cutting department salaries)\n\n<syntaxhighlight lang=\"java\">\npublic class DepartmentAction {\n\n\tprivate Department department;\n\tprivate String message;\n\t\n\t\n\t@Action(value = \"department.detail\", \n\t\t\tresults = {@Result(name = \"detail\", location=\"department-detail.jsp\")}\n\t)\n\tpublic String execute() {\n\t\t\/\/the next assignment exposes the department \n\t\t\/\/member as a \"bean\", so that the forwarded view (a JSP) \n\t\t\/\/component is able to access its value. \n\t\tdepartment = CompanyService.instance().findDepartment(Long.parseLong(RequestUtil.getRequestParameter(\"dptId\")));\n\t\treturn \"detail\";\n\t}\n\t\n\t@Action(value = \"department.cutSalariesOfDepartment\", \n\t\t\tresults = {@Result(name = \"detail\", location=\"department-detail.jsp\")}\n\t)\n\tpublic String cutSalariesOfSubunit() throws Exception {\t\n\t\tdepartment = CompanyService.instance().findDepartment(department.getId());\n\t\tdepartment.cut();\n\t\treturn \"detail\";\n\t}\n\t...\n<\/syntaxhighlight> \t\nBesides methods with the @Action annotation, the Department class looks like \na conventional Plain Old Java Object. The @Action annotation is used to expose \na class as an Struts Action, which might be later referred to by view components. \nIn addition, each @Action is parameterized according to a value, which \nmight be associated to a request; and a map of possible results, which relates \nthe return value of an action method to the next view whose request \nwill be redirected. Within JSPs, we could refer to actions as well \nas to properties of an Action class, as we show in \nthe next listing. \n\n<syntaxhighlight lang=\"html4strict\">\n...\n<s:form action=\"department.update\" >\n...\n<s:textfield label=\"Name\" value=\"%{department.name}\"  name=\"department.name\" \/> \n<s:textfield label=\"Manager\" value=\"%{department.manager.name}\" name=\"department.manager.name\" \/> \n<s:textfield label=\"Manager salary\" value=\"%{department.manager.salary}\" name=\"department.manager.salary\" \/> \n...\n\n<s:submit label=\"Cut\" value=\"Cut\" action=\"department.cutSalariesOfDepartment\"  \/>\n<\/s:form>\n<\/syntaxhighlight>",
	"usage":"=== Requirements ===\n\t\n\t        Any web server based on Servlet technology, such as [[Technology:Apache Tomcat]].\n\t        \n=== Build === \n\n\t        (a) run \"mvn clean package\" in the root directory of the Struts 2 implementation of 101companies\n\t        (b) copy target\/struts2app.war to the webs app of your web server\n\n=== Accessing the system ===\n\t\n\t        (a) start the web server\n\t        \n\t        (b) start a web browser and inform the URL http:\/\/localhost:8080\/struts2app, if the web server is configured to accept requests on the 8080 port   \n\n[[Category:Web application]]"
},
{
	"name":"strutsXml",
	"summary":"implement a web application with Struts, but the redirection ",
	"motivation":"This is a simple web implementation of the basic 101companies-features using  \nStruts2 (XML) and Serialization as persistence mechanism. \nIt provides server-side storage for the data using serialization.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"Java"},
		{"name":"JavaServer_Pages"},
		{"name":"XML"}],
	"technologies":[{"name":"Struts"}],
	"illustration":"The company data is stored in a serialization file. To obtain the stored data, there \nis an auxiliarly method in the Company class.\n\n<syntaxhighlight lang=\"java\">\npublic class Company { \n ...\npublic static Company readObject(String filename) {\n  Object o = null;\n  try {\n\tFileInputStream fis = new FileInputStream(filename);\n\tObjectInputStream in = new ObjectInputStream(fis);\n\to = in.readObject();\n\tin.close();\n  } catch (IOException e) {\n     e.printStackTrace();\n  } catch (ClassNotFoundException e) {\n\t e.printStackTrace();\n  }\n  return (Company) o;\n}\n...\n<\/syntaxhighlight>\nBased on the struts2 architecture, the controller layer is implemented \nby Java classes (action classes) that extend the class ActionSupport \nand implement the Preparable interface. This approach uses the \n'''xworks''' framework and a simple CRUD design, where only one \naction is necessary to all operations (edit and cut salaries of a \ndepartment, edit and cut salaries of an employee, and so on). CompanyAction \nis the  \nsingle Action class in this project, with the definition: \n\n<syntaxhighlight lang=\"java\">\npublic class CompanyAction extends ActionSupport implements Preparable {\n... \n}\n<\/syntaxhighlight>\n \n\nThe view layer might be implemented using \nJava Server Pages (JSPs) or other template languages such as Velocity. Here, \nwe use JSPs to implement the view layer. The listing bellow shows \na code fragment of the department.jsp view component. You should notice \nsome special tags such as '''s:form''' and '''s:iterator''', which are declared \nin the Struts tag library. Using theses tags we are able to refer to \nproperties of the action that redirected to the specific view. \n\n<syntaxhighlight lang=\"xml\">\n...\n<h2>Department details<\/h2>\n\n<s:form action=\"DEP!save.action\" method=\"post\">\n\t<s:textfield name=\"department.name\" value=\"%{department.name}\" label=\"Name\" size=\"30\" \/>\n\t<s:textfield name=\"department.manager.person.name\" value=\"%{department.manager.person.name}\" label=\"Manager\" size=\"30\" \/>\n\t<s:textfield name=\"department.manager.salary\" value=\"%{department.manager.salary}\" label=\"Manager salary\" size=\"15\" \/>\n\t<s:textfield name=\"department.manager.person.address\" value=\"%{department.manager.person.address}\" label=\"Manager address\" size=\"30\" \/>\n\t<s:textfield value=\"%{department.total()}\" label=\"Total salaries\" readonly=\"true\" size=\"30\" \/>\n\t<s:hidden name=\"empName\" value=\"%{department.manager.person.name}\" \/>\n\t<s:hidden name=\"deptName\" value=\"%{department.name}\" \/>\n\t<s:submit value=\"Save\" \/>\n\t<s:submit value=\"Cut\" action=\"cutSalaries\"\/>\n\t<s:submit value=\"Company details\" action=\"index\" \/>\n<\/s:form>\n<br>\n<h2><s:text name=\"Subdepartments\" \/><\/h2>\n<table class=\"outline\" border=\"1\" width=\"50%\">\n\t<tr>\n\t\t<th width=\"70%\"><s:text name=\"Name\" \/><\/th>\n\t\t<th width=\"30%\">Edit department<\/th>\n\t<\/tr>\n\t<s:iterator value=\"department.subunits\" status=\"status\">\n\t<tr>\n\t\t<s:if test=\"department\">\n\t\t\t<td class=\"nowrap\"><s:property value=\"name\" \/><\/td>\n\t\t\t<td class=\"nowrap\">\n\t\t\t\t<s:url action=\"DEP!input\" id=\"link\">\n\t\t\t\t\t<s:param name=\"department.name\" value=\"name\" \/>\n\t\t\t\t<\/s:url> \n\t\t\t\t<a href=\"<s:property value=\"#link\"\/>\">Detail<\/a>\n\t\t\t<\/td>\n\t\t<\/s:if>\n\t<\/tr>\n\t<\/s:iterator>\n<\/table>\n...\n<\/syntaxhighlight> \t\nAs explained, an XML file declares which view should \nbe displayed as an action response. For instance, if \nthe cutSalaries action was performed, the system should \nredirect to one of two components: department.jsp or \nemployee.jsp. This decision depends on \nthe returned value of the corresponding method (\nimplemented by the CompanyAction class). \n\n<syntaxhighlight lang=\"java>\npublic String cutSalaries() {\n  String redirect = SUCCESS;\n  if(department != null && deptName != null) {\n    service.cutDepartmentSalaries(deptName);\n\tredirect = DEPARTMENT_SAVE;\n  }\n  else if(employee != null && empName != null) {\n\tservice.cutEmployeeSalary(empName);\n\tredirect = EMPLOYEE_SAVE;\n  }\n  return redirect;\n}\n<\/syntaxhighlight>  \nThe struts.xml file informs the next view that \nshould be displayed, depending on the returned \nvalue of a call to the cutSalaries method.\n \n<syntaxhighlight lang=\"xml\">\n<action name=\"cutSalaries\" class=\"org.softlang.action.CompanyAction\" method=\"cutSalaries\">\n  <result name=\"department.save\">\/WEB-INF\/jsp\/department.jsp<\/result>\n  <result name=\"employee.save\">\/WEB-INF\/jsp\/employee.jsp<\/result>\n<\/action>\n<\/syntaxhighlight>",
	"usage":"(a) run mvn clean package\n(b) copy the target\/struts.war file to the webapps direcoty of your [[Technology:Apache Tomcat]] distribution\n(c) start your Tomcat distribution\n(d) point your browser to http:\/\/localhost:8080\/struts (replacing the port if necessary)",
	"issues":"* Potentially simplify Controller\/Service; no service object needed\n* Add substantial README\/code documentation\n\n[[Category:Web application]]"
},
{
	"name":"swing",
	"summary":"provide interaction on companies by means of [[Technology:Swing]]",
	"motivation":"Specifically, the GUI provides the following gestures:\n* Navigate hierarchical structure of departmental nesting.\n* Edit all fields of types string and number.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"},
		{"name":"interaction"}],
	"languages":[{"name":"Java"}],
	"technologies":[{"name":"Swing"},
		{"name":"AWT"}],
	"architecture":"The implementation uses a poorman's MVC architecture.\nIt is based on the object model of [[101implementation:javaComposition]].\nWe do not assume any change-notification services on the model.\nThere are two views: one for departments (and companies) and another for employees.\nThe controller provides services that push effect of gestures into the model.\nThe views delegates event handlers to the controller.\nThe controller calls into the model and the view.",
	"usage":"Run Interaction.java to start the GUI for the sample company."
},
{
	"name":"syb",
	"summary":"an implementation in [[Language:Haskell]] using [[SYB]]",
	"motivation":"Several of the 101companies features essentially involve traversal over \narbitrarily nested data. For instance, totaling all salaries requires\nthe location of salary subterms at all levels in the term. Hence, \nsupport for traversals can significantly help here. In fact, [[SYB]]\nstyle of generic programming can be put to work, and the corresponding\nfunction implementations become drastically more concise.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"mentoring"},
		{"name":"precedence"},
		{"name":"serialization"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"GHCi"}],
	"architecture":"The implementation is straightforward. \n\nThere are Haskell modules for the implemented operations.\n\n* [[101feature:Company]]: ''Company.hs''\n* [[101feature:Total]]: ''Total.hs''\n* [[101feature:Cut]]: ''Cut.hs''\n* [[101feature:Depth]]: ''Depth.hs''\n* [[101feature:Mentoring]]: ''Mentoring.hs''\n* [[101feature:Precedence]]: ''Precedence.hs''\n\n[[101feature:Serialization]] is enabled by \"deriving\" clauses for type classes ''Read'' and ''Show'' in ''Company.hs''.\n[[SYB]] style of generic programming is enabled by \"deriving\" clauses for type classes ''Typeable'' and ''Data'' in ''Company.hs''.\nFinally, there is a ''Main'' module which collects a few test scenarios; see below.",
	"usage":"The Haskell module ''Main'' has to be consulted with GHCi, and the\n''main'' function has to be applied so that output for the test\nscenarios is produced. The ''expected'' output is available through\nthe file ''baseline''. There is a ''Makefile'' with a target ''test''\nfor [[test automation]]."
},
{
	"name":"wcf",
	"summary":"[[Technology:WCF]] implementation in [[Technology:.NET]] 4.0",
	"motivation":"* Statefull server\n* ASP .NET session is used to store the state\n* [[Technology:SOAP]] is used for messaging\n* [[Technology:WSDL]] is used for client-side proxy generation\n* WCF service available in a \"singleton\" mode, i.e. only one service instance is created to handle all incoming calls.\n* Data transfer object (DTO) pattern is used to wrap domain model into lightweight containers (DTOs) and pass them on the client over http.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"distribution"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"WCF"},
		{"name":"IIS"}],
	"illustration":"Contract definition\n\n<syntaxhighlight lang=\"csharp\">\n    [ServiceContract]\n    public interface ICompanyService\n    {\n        [OperationContract]\n        CompanyDto GetCompany();\n      .......\n    }\n<\/syntaxhighlight >\nContract implementation\n\n<syntaxhighlight lang=\"csharp\">\n  [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]\n    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]\n    public class CompanyService : ICompanyService\n    {\n        .......\n        public CompanyDto GetCompany()\n        {\n            ........\n        }\n       .....\n     }\n<\/syntaxhighlight >",
	"architecture":"",
	"usage":"* Create a new web site (http:\/\/localhost:1212) under IIS pointing to the project folder.\n\n[MSDN] When creating a service anywhere other than on the Web site that hosts your Silverlight application, cross-domain issues can arise. Cross-domain calls between Silverlight applications and services present a security vulnerability and must be specifically enabled by an appropriate cross-domain policy. For procedures that describe how to implement such a policy, see Making a Service Available Across Domain Boundaries. See [http:\/\/msdn.microsoft.com\/en-us\/library\/cc197955(v=vs.95).aspx] for details"
},
{
	"name":"wcfRest",
	"summary":"REST-based service implemented in [[Technology:WCF]]",
	"motivation":"",
	"features":[{"name":"cut"},
		{"name":"total"},
		{"name":"distribution"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"WCF"},
		{"name":"Visual Studio"}],
	"architecture":"",
	"usage":"* Create a new web site under IIS pointing to the projects' directory. Use port 1234 for a newly created web site. Ensure you use .NET Framework 4.0 for the application pool.\n\n* By pressing F5 in VS you will get the browser opened; go to the following URL to get the full API description http:\/\/localhost:1234\/CompanyService\/help"
},
{
	"name":"webDSL",
	"summary":"this projects provides a very simple WebDSL WebApp for companies",
	"motivation":"We define pages (company\/department\/employee view) using the [http:\/\/webdsl.org WebDSL] DSL. \nWe also provide a metamodel for companies and scenerios to [[101feature:Cut|cut]] and [[101feature:Total|total]] salaries. \n\n=== Architecture of the project ===\n\n\"webDSL.app\" is the \"main file\", containing the page definitions.\n\"company.app\" holds the company model while meganalysis.app contains \"meganalysis\" as an instance of the model.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"distribution"}],
	"languages":[{"name":"JavaScript"}],
	"technologies":[],
	"usage":"We make use of the WebDSL Plugin. Update Site: http:\/\/webdsl.org\/page\/Download\n\n* Build the project by running the Ant Build file\n* Select the project in the package explorer -> right click -> Run As -> Run on Server\n* Select your preferred server (we made use of [[Technology:Apache Tomcat]] v6.0 Server) and click \"Next\"\n* Click \"Download and Install\" and follow the menu's steps\n* Click \"Finish\"\n* The project will be published on the installed server\n* Visit http:\/\/localhost:8080\/webDSL\/ \n(Eventually you will have to re-build or restart the server)\n\n[[Category:Web application]]"
},
{
	"name":"wp7",
	"summary":"A basic Windows Phone 7 implementation",
	"motivation":"We show\n\n* 1. Usage of MVC for developing UI.\n* 2. Declarative data binding using XAML (xml-based language), essentially different supported types (One-Way and Two-Way) of binding.\n* 3. Reactive programming model, where the model (in terms of MVC architecture) exposes observable properties.",
	"features":[{"name":"company"},
		{"name":"cut"},
		{"name":"total"},
		{"name":"interaction"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"Silverlight"},
		{"name":"Visual Studio"},
		{"name":"WP7 SDK"}],
	"illustration":"* Properties support notification\n* XAML binding\n* Navigation between views",
	"architecture":"Every entity has a view represented as XAML file with the UI layout and data binding.\n\nThe project also references the company's model created as a Silverlight class library. This is necessary because WP7 projects can't reference regular C# projects -- Silverlight runtime used in WP7 projects is a more limited version of the CLR.",
	"usage":"In order to run the application Windows Phone 7 tools for Visual Studio 2010 have to be installed. At the time of writing this README, [http:\/\/www.microsoft.com\/download\/en\/details.aspx?id=23854 January 2011 Update] is the most recent version.\n\n[[Technology:Visual Studio]] 2010 should be used to open a project file.\n\nThe project should be compiled as a regular VS project and deployed into an emulator by clicking the right mouse button on the project file in VS and selecting \"deploy\" menu item. WP7 emulator will be started automatically with an application deployed."
},
{
	"name":"wpf",
	"summary":"an implementation with UI in [[Technology:WPF]]",
	"motivation":"",
	"features":[],
	"languages":[{"name":"CSharp"}],
	"technologies":[],
	"architecture":"",
	"usage":""
},
{
	"name":"wxHaskell",
	"summary":"Provide [[101feature:Interaction|interaction]] on companies by means of [[Technology:wxHaskell]]",
	"motivation":"We use the [[Technology:wxHaskell]] library to provide a simple GUI for [[101feature:Company|companies]]. \nOne can navigate the hierarchical company structure, [[101feature:Cut|cut]] [[101feature:Total|totaled]] salaries and edit fields for values of [[Primitive Type|primitive types]]. \nWe make use of the [[Zipper|Zipper]] inspired focus concept to specify which part of the company should be shown or saved after editing.\nThis concept also helps us to read departments\/employees from a given position within the company and write transformed departments\/employees back.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"}],
	"languages":[{"name":"Haskell"}],
	"technologies":[{"name":"wxHaskell"},
		{"name":"GHC"},
		{"name":"GHCi"}],
	"illustration":"=== Focus datatype ===\n\nWe are using a datastructure inspired by the concept of [[Zipper|Zippers]] to specify positions of components within the company. We provide an algebraic datatype <syntaxhighlight lang=\"haskell\" enclose=\"none\">Focus<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"wxHaskell\/Focus.hs\" line>\ndata Focus = \n     CompanyFocus\n   | DeptFocus [Int]\n   | ManagerFocus [Int]\n   | EmployeeFocus [Int] Int\n    deriving (Show, Read)\n<\/syntaxhighlight>\nWe define one constructor per company datatype and one for managers. For example to construct a focus for an employee one needs to pass:\n* A list of indexes: Starting from the company root this list is used to navigate through the departments and subdepartments to the employee's department.\n* An index: The index of this employee in the employee's department's employees list.\nOn top of this definition we provide functions to get sub and upper foci and to read and write company components (see [this!!Focus.hs] for details).\n\n=== The views ===\n\nFor each company datatype, that is <syntaxhighlight lang=\"haskell\" enclose=\"none\">Company<\/syntaxhighlight>, <syntaxhighlight lang=\"haskell\" enclose=\"none\">Department<\/syntaxhighlight> and <syntaxhighlight lang=\"haskell\" enclose=\"none\">Employee<\/syntaxhighlight>, [this!!Views.hs] provides a view to display the specific component including buttons to navigate and cut salaries. All of these functions are of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">Frame () -> Focus -> Company -> IO ()<\/syntaxhighlight>. That is, given the global frame, a focus and a company these functions perform GUI actions (which are IO actions). \nIn the following we demonstrate how an employee is displayed.\n\n==== Viewing an employee ====\n\n<syntaxhighlight lang=\"haskell\" enclose=\"none\">showEmployee<\/syntaxhighlight> is the view function for employees:\n\n<syntaxhighlight lang=\"haskell\" source=\"wxHaskell\/Views.hs\" line>\nviewEmployee :: Frame () -> Focus -> Company -> IO ()\nviewEmployee f focus c = do\n    -- reading employee\n    let e = readEM focus c\n    -- setting up frames and panels\n    set f [ text := \"Employee \\\"\" ++ ename e ++ \"\\\"\"]\n    p <- panel f [textColor := textBlue]\n    -- boxes for name, address and salary\n    nameBox <- entry p [text := ename e]                                    \n    addressBox <- entry p [text := address e]\n    salaryBox <- entry p [text := show $ salary e]\n    -- cut button\n    cButton <- cutButton p f focus c\n    -- back button                                \n    bButton <- backButton p f focus c           \n    -- save button                                                             \n    sButton <- button  p \n          [ text := \"Save\"\n          , size := Size 50 22 \n          , on command := do { \n              newName <- get nameBox text;\n              newAddress <- get addressBox text;\n              newSalary <- get salaryBox text;\n              objectDelete p;\n              viewEmployee f focus $ \n               writeEM focus c $ \n                Employee newName newAddress $ \n                 read newSalary; }]\n    -- compose layout                                 \n    setEmployeeLayout f p sButton bButton nameBox addressBox salaryBox cButton\n<\/syntaxhighlight>\nIn line 4 we read the employee in question using the ''Focus'' module's function <syntaxhighlight lang=\"haskell\" enclose=\"none\">readEM<\/syntaxhighlight>. In lines 6-7 we set the frame title and create a new panel for this view. In lines 9-11 we create one input box per employee field. We create buttons to cut the employee's salary and to go back to the department level in lines 13-15. In lines 17-28 we set up a save button: When a user clicks the button, the name, address and salary fields are read, the panel is deleted, the employee is updated in the company and the new company is displayed. In the last line  we call <syntaxhighlight lang=\"haskell\" enclose=\"none\">setEmployeeLayout<\/syntaxhighlight>, which composes the layout using various layout combinators (see [this!!Views.hs] for details).\n\n=== Cutting button ===\n\nOn each view the GUI provides a button to cut all salaries: \n\n<syntaxhighlight lang=\"haskell\" source=\"wxHaskell\/Views.hs\" line>\ncutButton :: Panel () -> Frame () -> Focus -> Company -> IO (Button ())\ncutButton p f focus c = \n  button p [ text := \"Cut\"      \n           , size := Size 50 22                                                                \n           , on command := do {\n                objectDelete p; \n                view f focus $ readCutWrite focus c;}]   \n<\/syntaxhighlight>\nWhen the user clicks the button the <syntaxhighlight lang=\"haskell\" enclose=\"none\">command<\/syntaxhighlight> action (lines 5-7) is executed. First the view's panel is deleted in line 6. We use <syntaxhighlight lang=\"haskell\" enclose=\"none\">readCutWrite<\/syntaxhighlight> to cut the company component's salaries. This function reads the component in question based on the focus, then cuts this component's salaries and replaces it in the given company. In line 7 the <syntaxhighlight lang=\"haskell\" enclose=\"none\">command<\/syntaxhighlight> action calls <syntaxhighlight lang=\"haskell\" enclose=\"none\">view<\/syntaxhighlight> to view the company, department or employee. Based on the focus <syntaxhighlight lang=\"haskell\" enclose=\"none\">view<\/syntaxhighlight> decides which concrete view-function to call:\n\n<syntaxhighlight lang=\"haskell\" source=\"wxHaskell\/Views.hs\" line>\nview:: Frame () -> Focus -> Company -> IO ()\nview f focus = view' f focus\n  where \n    view' = case focus of\n              CompanyFocus        -> viewCompany\n              (DeptFocus _)       -> viewDept\n              (EmployeeFocus _ _) -> viewEmployee\n              (ManagerFocus _)    -> viewEmployee       \n<\/syntaxhighlight>\n=== Starting the GUI ===\n\nWe use xwHaskell's <syntaxhighlight lang=\"haskell\" enclose=\"none\">start :: IO a -> IO ()<\/syntaxhighlight>. This function runs the given GUI of type <syntaxhighlight lang=\"haskell\" enclose=\"none\">IO a<\/syntaxhighlight> while discarding <syntaxhighlight lang=\"haskell\" enclose=\"none\">a<\/syntaxhighlight> and returning <syntaxhighlight lang=\"haskell\" enclose=\"none\">IO ()<\/syntaxhighlight>:\n\n<syntaxhighlight lang=\"haskell\" source=\"wxHaskell\/Main.hs\" line>\ngui :: IO ()\ngui = do\n    f <- frame [ textBgcolor := colorRGB 112 128 144 \n               , resizeable := False\n               , fontWeight := WeightBold\n               , fontUnderline := False\n               , position := Point 50 50]\n    showCompany f CompanyFocus company \n\nmain :: IO ()\nmain = start gui\n<\/syntaxhighlight>\nIn lines 3-7 <syntaxhighlight lang=\"haskell\" enclose=\"none\">gui<\/syntaxhighlight> creates the main frame for all views passing a list attributes, which are assigned by making use of assign operator <syntaxhighlight lang=\"haskell\" enclose=\"none\">(:=)<\/syntaxhighlight>. In the last line the function calls <syntaxhighlight lang=\"haskell\" enclose=\"none\">showCompany<\/syntaxhighlight> passing the frame, the root focus and a sample company in line 8.",
	"architecture":"[this!!Views.hs] provides one view per company datatype. [this!!Main.hs] starts the GUI. The algebraic datatype for companies can be found in [this!!Company.hs], a sample company in [this!!SampleCompany.hs]. [this!!Focus.hs] provides a focus datatype and functions on top of it. [this!!Total.hs] and [this!!Cut.hs] provide functionality to total and cut salaries.",
	"usage":"* [this!!Main.hs] has to be compiled using GHC\n* The output executable has to run. \nThere is a ''Makefile'' with a target ''start'' covering both stepts."
},
{
	"name":"xom",
	"summary":"exercise [[in-memory XML processing]] with [[Technology:XOM]] in [[Language:Java]]",
	"motivation":"See [[101implementation:dom]] for a general motivation for exercising\n[[in-memory XML processing]]. The present implementation simply exercises\nyet another DOM-like API. We end up providing a descendants axis to this\nend.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"}],
	"languages":[{"name":"XML"},
		{"name":"Java"}],
	"technologies":[{"name":"XOM"}],
	"usage":"* The implementation is provided as an Eclipse project.\n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available though class ''org.softlang.xom.Tests''."
},
{
	"name":"xpathAPI",
	"summary":"exercise [[:Category:XML processing]] with [[Language:XPath]] embedded in [[Language:Java]]",
	"motivation":"XPath can be embedded in Java code which makes it possible to process\nquery results in Java. Query results are bound to DOM-like node sets, and\none can iterate over those and mutate them, thereby implementing\nimpure transformations.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XPath"},
		{"name":"Java"}],
	"technologies":[{"name":"Xalan-Java"},
		{"name":"JAXP"}],
	"architecture":"See [[101implementation:dom]] for a very similar implementation.\nThe main difference to the [[Technology:DOM]]-based implementation\nis really that an XPath query is used in the place of a DOM query axis. \nXalan-Java is included into the code distribution of this implementation;\nit implements an XPath processor.",
	"usage":"* The implementation is provided as an Eclipse project. \n* Hence, open the project with Eclipse; this will also build the project.\n* There are JUnit tests available in the package ''org.softlang.tests''.\n** Run class ''Operations'' with JUnit to exercise basic operations."
},
{
	"name":"xquery",
	"summary":"exercise [[:Category:XML processing]] with [[Language:XQuery]]",
	"motivation":"",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"}],
	"languages":[{"name":"XML"},
		{"name":"XQuery"}],
	"technologies":[{"name":"Saxon"},
		{"name":"BaseX"},
		{"name":"Java SE"}],
	"architecture":"There are two implementations of [[101feature:Cut]]:\n* cut.xq: uses XQuery w\/o update facility\n* cut.uf.xq: uses XQuery w\/ update facility",
	"usage":"See the Makefile for running some tests.\n\nVersions of Saxon and BaseX are included in the code repository for this implementation.\n\nTested with this version of BaseX:\n\n<pre>\n$ java -cp basex\/BaseX61.jar org.basex.BaseX -h\nBaseX 6.1; DBIS, University of Konstanz\nUsage: BaseX [-dioqsvVxz] [query] [-c]\n  [query]    query file\n  -c<cmd>    database commands\n  -d         debug mode\n  -i<file>   XML input\n  -o<file>   output file\n  -q<expr>   query expression\n  -s<pars>   serialization parameters\n  -v\/V       show (all) process info\n  -w         wrap query result to xml\n  -z         skip query output\n<\/pre>\n\nTested with this version of Saxon:\n\n<pre>\n$ java -jar saxon\/saxon9he.jar\nNo source file name\nSaxon-HE 9.2.1.2J from Saxonica\nUsage: see http:\/\/www.saxonica.com\/documentation\/using-xsl\/commandline.html\nOptions: \n   ...\n<\/pre>\n\nTested on the following machines:\n\n<pre>\n\tDarwin ... 9.8.0 Darwin Kernel Version 9.8.0: Wed Jul 15 16:55:01 PDT 2009; root:xnu-1228.15.4~1\/RELEASE_I386 i386\n\t\t(both test-saxon and test-basex)\n\tDarwin ... 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT \n\t\t(both test-saxon and test-basex)\n2011; root:xnu-1504.15.3~1\/RELEASE_I386 i386\n\tLinux ... 2.6.32-21-generic #32-Ubuntu SMP Fri Apr 16 08:09:38 UTC 2010 x86_64 GNU\/Linux\n\t\t(both test-saxon and test-basex-unix)\n\tMicrosoft Windows XP [Version 5.1.2600]\n\t\t(both with and without update facility)\n<\/pre>\n\nThe project can be opened with Eclipse for convenience."
},
{
	"name":"xsdClasses",
	"summary":"X\/O mapping with [[Technology:xsd.exe]] and [[Language:CSharp | C#]].",
	"motivation":"X\/O mapping within the .NET platform is exercised. The implementation is also motivated by the [[101implementation:jaxbComposition]] and aims to compare Java and .NET approaches.\n[[Technology:xsd.exe]] is used to generate [[Language:CSharp|C#]] classes from the schema.\nWe show one of the xsd.exe usage scenarios, where C# object model generated from XSD schema is used to deserialize XML which match the same XSD. We apply .NET XML serialization API to support X\/O mapping of the actual XML data. To this end we say that xsd.exe is used to map XSD\/C# type systems, which are used by .NET XML serialization API to se\/de-serialize the actual data.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"NUnit"}],
	"architecture":"Company.xsd is the schema for schema-first mapping. Company.cs is an output produced by applying xsd.exe to the schema file.\nFeatures.cs contains a [[partial class]] with [[101feature:Total]] and [[101feature:Cut]] implementations. In fact they are an exact copy of [[101implementation:csharp]]\nSampleCompany.xml contains the serialized company and used in unit tests.\n\nBoth XSD and XML files are taken from [[101implementation:jaxbComposition]] with one minor change: types' names are capitalized to follow C# coding best practices.",
	"usage":"[[Technology:Visual Studio]] 2010 should be used to open a project file.\nThe project itself is a class-library and compiles into a DLL. To run a project you must execute at least one unit test (or all at once).\nNunit GUI or other Visual studio extension (e.g. Resharper) should be used for executing unit tests.\n\nThe following command should be used if one wants to re-generate C# sources from xsd file:\nxsd Company.xsd \/classes \/out:..\/"
},
{
	"name":"xsdDataSet",
	"summary":"X\/O\/R mapping with [[Technology:xsd.exe]] and strongly typed DataSets",
	"motivation":"X\/O mapping within the .NET platform is exercised. This is a variation of [[101implementation:xsdClasses]]; we generate typed DataSets opposite to plain objects.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"serialization"}],
	"languages":[{"name":"CSharp"}],
	"technologies":[{"name":"csc.exe"},
		{"name":".NET"},
		{"name":"NUnit"}],
	"architecture":"Follows those applied to a [[101implementation:xsdClasses]].",
	"usage":"[[Technology:Visual Studio]] 2010 should be used to open a project file.\nThe project itself is a class-library and compiles into a DLL. To run a project you must execute at least one unit test (or all at once).\nNunit GUI or other Visual studio extension (e.g. Resharper) should be used for executing unit tests.\n\nThe following command should be used if one wants to re-generate C# sources from xsd file: xsd Company.xsd \/dataset \/out:..\/"
},
{
	"name":"xslt",
	"summary":"exercise [[:Category:XML processing]] with [[Language:XSLT]]",
	"motivation":"XSLT is easily applied to the basic query\/transformation features.\nStructurally recursive,\n[[endogenous transformation]]s are taken care of by XSLT transformations\nthat leverage the \"copy-recurse\" idiom for all elements that do not require\nany \"local\" change; see below. Structurally recursive queries are handled similarly;\noutput mode \"text\" is used, though.\n\n'''\"copy-recurse\" idiom:'''\n\n<pre>\n\t<xsl:template match=\"@*|node()\">\n\t\t<xsl:copy>\n\t\t\t<xsl:apply-templates select=\"@*|node()\"\/>\n\t\t<\/xsl:copy>\n\t<\/xsl:template>\n<\/pre>",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"depth"},
		{"name":"serialization"}],
	"languages":[{"name":"XML"},
		{"name":"XSLT"},
		{"name":"XSD"}],
	"technologies":[{"name":"xsltproc"},
		{"name":"Saxon"}],
	"architecture":"Each of the implemented query\/transformation features is modeled by a designated XML transformation.",
	"usage":"See the Makefile for running some tests.\n\nAn xsltproc implementation is readily available on OS X, Linux et al.\n\nA version of Saxon is included in the code repository for this implementation.\n\nTested with this version of xsltproc:\n\n<pre>\n$ xsltproc -V\nUsing libxml 20703, libxslt 10124 and libexslt 813\nxsltproc was compiled against libxml 20703, libxslt 10124 and libexslt 813\nlibxslt 10124 was compiled against libxml 20703\nlibexslt 813 was compiled against libxml 20703\n\nAlso possible to work with Saxon from:\n\thttp:\/\/saxon.sourceforge.net\/ or http:\/\/www.saxonica.com\/\n<\/pre>\n\nTested with this version of Saxon:\n\n<pre>\n$ java -jar saxon\/saxon9he.jar\nNo source file name\nSaxon-HE 9.2.1.2J from Saxonica\nUsage: see http:\/\/www.saxonica.com\/documentation\/using-xsl\/commandline.html\nOptions: \n   ...\n<\/pre>\n\nTested on the following machines:\n\n<pre>\n\tDarwin ... 9.8.0 Darwin Kernel Version 9.8.0: Wed Jul 15 16:55:01 PDT 2009; root:xnu-1228.15.4~1\/RELEASE_I386 i386\n\t\t(both test-xsltproc and test-saxon)\n\tDarwin ... 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1\/RELEASE_I386 i386\n\t\t(both test-xsltproc and test-saxon)\n\tLinux ... 2.6.32-21-generic #32-Ubuntu SMP Fri Apr 16 08:09:38 UTC 2010 x86_64 GNU\/Linux\n\t\t(both test-xsltproc and test-saxon with Java 6)\n\tLinux ... 2.6.16.60-0.69.1-ppc64 #1 SMP Fri Sep 17 17:07:54 UTC 2010 ppc64 ppc64 ppc64 GNU\/Linux\n\t\t(only test-xsltproc due to the lack of Java 5+)\n\tLinux ... 2.6.13-15.18-bigsmp #1 SMP Tue Oct 2 17:36:20 UTC 2007 i686 i686 i386 GNU\/Linux\n\t\t(only test-xsltproc due to the lack of any Java)\n\tMicrosoft Windows XP [Version 5.1.2600]\n\t\t(only saxon due to the lack of xsltproc)\n<\/pre>\n\nThe project can be opened with Eclipse for convenience."
},
{
	"name":"zend",
	"summary":"[[web programming]] with [[Language:PHP]] and the [[Technology:Zend framework]]",
	"motivation":"[[Language:PHP]] is one of the most common [[:Category:Language|languages]] for [[web programming]]. To get a more structured and valuable [[:Category:101implementation|implementation]], it is reasonable to choose a [[Language:PHP]] based [[:Category:web-application framework]]. The [[Technology:Zend framework]] provides a good infrastructure and a large amount of pre-assembled components.",
	"features":[{"name":"company"},
		{"name":"total"},
		{"name":"cut"},
		{"name":"interaction"},
		{"name":"persistence"},
		{"name":"precedence"},
		{"name":"validation"}],
	"languages":[{"name":"PHP"},
		{"name":"HTML"},
		{"name":"CSS"}],
	"technologies":[{"name":"Zend framework"}],
	"illustration":"The features [[101feature:Total]] and [[101feature:Cut]] are both implemented in the [this!!application\/models\/DbTable\/Employee.php models\/dbTables\/Employee.php]-[[Model View Controller|model]]. The reason is, that these methods affect only employees, depend on the corresponding company or department. The automatic detection for the right data-table, provided by the variable ''$_name'' in the specific model, offers a simple structuring of the methods:\n\n<syntaxhighlight lang=\"php\" source=\"zend\/application\/models\/DbTable\/Employee.php\" line>\nprotected $_name = 'employee';\n\n...\n\npublic function getTotalForCompany($id) {\n    $id = (int)$id;\n    $rows = $this->fetchAll('cid = ' . $id);\n    $total = 0;\n    foreach ($rows as $row) {\n        $total += $row->salary;\n    }\n    return $total;\n}\n<\/syntaxhighlight>\nThis method returns the total-value for a company with a given ''$id''.\n\n[[:Category:Client]]-side can be easily implemented into the forms (e.g. [this!!application\/forms\/Employee.php forms\/Employee.php]): TODO",
	"architecture":"* The architecture is strictly based on the [[Model View Controller|MVC]]-pattern. There are different folders for the models, the views and the controllers. This is fundamental, because the [[:Category:framework]] automatically identifies the classes and its concerns with the help of these namespaces.\n* The adapter for the database connection is also automatically generated. The user only needs to configure the connection parameters and the nature of the adapter (e.g. for [[Technology:MySQL]], [[Technology:OracleDB]] etc.) in the [this!!application\/configs\/application.ini application.ini].\n* [[Technology:Zend framework]] has a great support for form-based websites. That means, that it is possible to generate forms with almost no [[Language:HTML]]-Code, because the framework automatically generates the website out of the php-objects defined in a given form (e.g. [this!!application\/forms\/Employee.php forms\/Employee.php]).",
	"usage":"* Download the implementation from the svn\n\nThis project needs a running [[Technology:MySQL]]-database. We recommend [[Technology:XAMPP]].\nYou can use the ''company.sql'' and ''sampleCompany.sql'' of [[101implementation:mySql]] for this project.\n\n* Download and install [[Technology:XAMPP]]\n* Open the \"XAMPP Control Panel\" and start \"Apache\" and \"MySQL\"\n* Use the guideline of [[101implementation:mySql]] up to \"Populate tables...\"\n\nAfter the database has started:\n\n* Copy the complete zend folder to the htdocs-directory of your XAMPP-installation\n* Start your [[:Category:Webbrowser]] and go to [http:\/\/localhost\/zend\/public\/]\n\nIf you want to continue with the development of this [[:Category:101implementation]], please download [[Technology:NetBeans]] and import the project to this [[:Category:IDE]]."
}
]
